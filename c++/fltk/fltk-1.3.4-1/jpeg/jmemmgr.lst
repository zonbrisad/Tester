   1              		.file	"jmemmgr.c"
   2              		.text
   3              	.Ltext0:
   4              		.section	.text.unlikely.do_barray_io,"ax",@progbits
   5              	.LCOLDB0:
   6              		.section	.text.do_barray_io,"ax",@progbits
   7              	.LHOTB0:
   8              		.p2align 4,,15
   9              		.section	.text.unlikely.do_barray_io
  10              	.Ltext_cold0:
  11              		.section	.text.do_barray_io
  13              	do_barray_io:
  14              	.LFB70:
  15              		.file 1 "fltk-1.3.4-1/jpeg/jmemmgr.c"
   1:fltk-1.3.4-1/jpeg/jmemmgr.c **** /*
   2:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * jmemmgr.c
   3:fltk-1.3.4-1/jpeg/jmemmgr.c ****  *
   4:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * Copyright (C) 1991-1997, Thomas G. Lane.
   5:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * Modified 2011-2012 by Guido Vollbeding.
   6:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * This file is part of the Independent JPEG Group's software.
   7:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * For conditions of distribution and use, see the accompanying README file.
   8:fltk-1.3.4-1/jpeg/jmemmgr.c ****  *
   9:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * This file contains the JPEG system-independent memory management
  10:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * routines.  This code is usable across a wide variety of machines; most
  11:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * of the system dependencies have been isolated in a separate file.
  12:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * The major functions provided here are:
  13:fltk-1.3.4-1/jpeg/jmemmgr.c ****  *   * pool-based allocation and freeing of memory;
  14:fltk-1.3.4-1/jpeg/jmemmgr.c ****  *   * policy decisions about how to divide available memory among the
  15:fltk-1.3.4-1/jpeg/jmemmgr.c ****  *     virtual arrays;
  16:fltk-1.3.4-1/jpeg/jmemmgr.c ****  *   * control logic for swapping virtual arrays between main memory and
  17:fltk-1.3.4-1/jpeg/jmemmgr.c ****  *     backing storage.
  18:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * The separate system-dependent file provides the actual backing-storage
  19:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * access code, and it contains the policy decision about how much total
  20:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * main memory to use.
  21:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * This file is system-dependent in the sense that some of its functions
  22:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * are unnecessary in some systems.  For example, if there is enough virtual
  23:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * memory so that backing storage will never be used, much of the virtual
  24:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * array control logic could be removed.  (Of course, if you have that much
  25:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * memory then you shouldn't care about a little bit of unused code...)
  26:fltk-1.3.4-1/jpeg/jmemmgr.c ****  */
  27:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
  28:fltk-1.3.4-1/jpeg/jmemmgr.c **** #define JPEG_INTERNALS
  29:fltk-1.3.4-1/jpeg/jmemmgr.c **** #define AM_MEMORY_MANAGER	/* we define jvirt_Xarray_control structs */
  30:fltk-1.3.4-1/jpeg/jmemmgr.c **** #include "jinclude.h"
  31:fltk-1.3.4-1/jpeg/jmemmgr.c **** #include "jpeglib.h"
  32:fltk-1.3.4-1/jpeg/jmemmgr.c **** #include "jmemsys.h"		/* import the system-dependent declarations */
  33:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
  34:fltk-1.3.4-1/jpeg/jmemmgr.c **** #ifndef NO_GETENV
  35:fltk-1.3.4-1/jpeg/jmemmgr.c **** #ifndef HAVE_STDLIB_H		/* <stdlib.h> should declare getenv() */
  36:fltk-1.3.4-1/jpeg/jmemmgr.c **** extern char * getenv JPP((const char * name));
  37:fltk-1.3.4-1/jpeg/jmemmgr.c **** #endif
  38:fltk-1.3.4-1/jpeg/jmemmgr.c **** #endif
  39:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
  40:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
  41:fltk-1.3.4-1/jpeg/jmemmgr.c **** /*
  42:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * Some important notes:
  43:fltk-1.3.4-1/jpeg/jmemmgr.c ****  *   The allocation routines provided here must never return NULL.
  44:fltk-1.3.4-1/jpeg/jmemmgr.c ****  *   They should exit to error_exit if unsuccessful.
  45:fltk-1.3.4-1/jpeg/jmemmgr.c ****  *
  46:fltk-1.3.4-1/jpeg/jmemmgr.c ****  *   It's not a good idea to try to merge the sarray and barray routines,
  47:fltk-1.3.4-1/jpeg/jmemmgr.c ****  *   even though they are textually almost the same, because samples are
  48:fltk-1.3.4-1/jpeg/jmemmgr.c ****  *   usually stored as bytes while coefficients are shorts or ints.  Thus,
  49:fltk-1.3.4-1/jpeg/jmemmgr.c ****  *   in machines where byte pointers have a different representation from
  50:fltk-1.3.4-1/jpeg/jmemmgr.c ****  *   word pointers, the resulting machine code could not be the same.
  51:fltk-1.3.4-1/jpeg/jmemmgr.c ****  */
  52:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
  53:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
  54:fltk-1.3.4-1/jpeg/jmemmgr.c **** /*
  55:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * Many machines require storage alignment: longs must start on 4-byte
  56:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * boundaries, doubles on 8-byte boundaries, etc.  On such machines, malloc()
  57:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * always returns pointers that are multiples of the worst-case alignment
  58:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * requirement, and we had better do so too.
  59:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * There isn't any really portable way to determine the worst-case alignment
  60:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * requirement.  This module assumes that the alignment requirement is
  61:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * multiples of sizeof(ALIGN_TYPE).
  62:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * By default, we define ALIGN_TYPE as double.  This is necessary on some
  63:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * workstations (where doubles really do need 8-byte alignment) and will work
  64:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * fine on nearly everything.  If your machine has lesser alignment needs,
  65:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * you can save a few bytes by making ALIGN_TYPE smaller.
  66:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * The only place I know of where this will NOT work is certain Macintosh
  67:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * 680x0 compilers that define double as a 10-byte IEEE extended float.
  68:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * Doing 10-byte alignment is counterproductive because longwords won't be
  69:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * aligned well.  Put "#define ALIGN_TYPE long" in jconfig.h if you have
  70:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * such a compiler.
  71:fltk-1.3.4-1/jpeg/jmemmgr.c ****  */
  72:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
  73:fltk-1.3.4-1/jpeg/jmemmgr.c **** #ifndef ALIGN_TYPE		/* so can override from jconfig.h */
  74:fltk-1.3.4-1/jpeg/jmemmgr.c **** #define ALIGN_TYPE  double
  75:fltk-1.3.4-1/jpeg/jmemmgr.c **** #endif
  76:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
  77:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
  78:fltk-1.3.4-1/jpeg/jmemmgr.c **** /*
  79:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * We allocate objects from "pools", where each pool is gotten with a single
  80:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * request to jpeg_get_small() or jpeg_get_large().  There is no per-object
  81:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * overhead within a pool, except for alignment padding.  Each pool has a
  82:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * header with a link to the next pool of the same class.
  83:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * Small and large pool headers are identical except that the latter's
  84:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * link pointer must be FAR on 80x86 machines.
  85:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * Notice that the "real" header fields are union'ed with a dummy ALIGN_TYPE
  86:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * field.  This forces the compiler to make SIZEOF(small_pool_hdr) a multiple
  87:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * of the alignment requirement of ALIGN_TYPE.
  88:fltk-1.3.4-1/jpeg/jmemmgr.c ****  */
  89:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
  90:fltk-1.3.4-1/jpeg/jmemmgr.c **** typedef union small_pool_struct * small_pool_ptr;
  91:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
  92:fltk-1.3.4-1/jpeg/jmemmgr.c **** typedef union small_pool_struct {
  93:fltk-1.3.4-1/jpeg/jmemmgr.c ****   struct {
  94:fltk-1.3.4-1/jpeg/jmemmgr.c ****     small_pool_ptr next;	/* next in list of pools */
  95:fltk-1.3.4-1/jpeg/jmemmgr.c ****     size_t bytes_used;		/* how many bytes already used within pool */
  96:fltk-1.3.4-1/jpeg/jmemmgr.c ****     size_t bytes_left;		/* bytes still available in this pool */
  97:fltk-1.3.4-1/jpeg/jmemmgr.c ****   } hdr;
  98:fltk-1.3.4-1/jpeg/jmemmgr.c ****   ALIGN_TYPE dummy;		/* included in union to ensure alignment */
  99:fltk-1.3.4-1/jpeg/jmemmgr.c **** } small_pool_hdr;
 100:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 101:fltk-1.3.4-1/jpeg/jmemmgr.c **** typedef union large_pool_struct FAR * large_pool_ptr;
 102:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 103:fltk-1.3.4-1/jpeg/jmemmgr.c **** typedef union large_pool_struct {
 104:fltk-1.3.4-1/jpeg/jmemmgr.c ****   struct {
 105:fltk-1.3.4-1/jpeg/jmemmgr.c ****     large_pool_ptr next;	/* next in list of pools */
 106:fltk-1.3.4-1/jpeg/jmemmgr.c ****     size_t bytes_used;		/* how many bytes already used within pool */
 107:fltk-1.3.4-1/jpeg/jmemmgr.c ****     size_t bytes_left;		/* bytes still available in this pool */
 108:fltk-1.3.4-1/jpeg/jmemmgr.c ****   } hdr;
 109:fltk-1.3.4-1/jpeg/jmemmgr.c ****   ALIGN_TYPE dummy;		/* included in union to ensure alignment */
 110:fltk-1.3.4-1/jpeg/jmemmgr.c **** } large_pool_hdr;
 111:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 112:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 113:fltk-1.3.4-1/jpeg/jmemmgr.c **** /*
 114:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * Here is the full definition of a memory manager object.
 115:fltk-1.3.4-1/jpeg/jmemmgr.c ****  */
 116:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 117:fltk-1.3.4-1/jpeg/jmemmgr.c **** typedef struct {
 118:fltk-1.3.4-1/jpeg/jmemmgr.c ****   struct jpeg_memory_mgr pub;	/* public fields */
 119:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 120:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Each pool identifier (lifetime class) names a linked list of pools. */
 121:fltk-1.3.4-1/jpeg/jmemmgr.c ****   small_pool_ptr small_list[JPOOL_NUMPOOLS];
 122:fltk-1.3.4-1/jpeg/jmemmgr.c ****   large_pool_ptr large_list[JPOOL_NUMPOOLS];
 123:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 124:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Since we only have one lifetime class of virtual arrays, only one
 125:fltk-1.3.4-1/jpeg/jmemmgr.c ****    * linked list is necessary (for each datatype).  Note that the virtual
 126:fltk-1.3.4-1/jpeg/jmemmgr.c ****    * array control blocks being linked together are actually stored somewhere
 127:fltk-1.3.4-1/jpeg/jmemmgr.c ****    * in the small-pool list.
 128:fltk-1.3.4-1/jpeg/jmemmgr.c ****    */
 129:fltk-1.3.4-1/jpeg/jmemmgr.c ****   jvirt_sarray_ptr virt_sarray_list;
 130:fltk-1.3.4-1/jpeg/jmemmgr.c ****   jvirt_barray_ptr virt_barray_list;
 131:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 132:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* This counts total space obtained from jpeg_get_small/large */
 133:fltk-1.3.4-1/jpeg/jmemmgr.c ****   long total_space_allocated;
 134:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 135:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* alloc_sarray and alloc_barray set this value for use by virtual
 136:fltk-1.3.4-1/jpeg/jmemmgr.c ****    * array routines.
 137:fltk-1.3.4-1/jpeg/jmemmgr.c ****    */
 138:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JDIMENSION last_rowsperchunk;	/* from most recent alloc_sarray/barray */
 139:fltk-1.3.4-1/jpeg/jmemmgr.c **** } my_memory_mgr;
 140:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 141:fltk-1.3.4-1/jpeg/jmemmgr.c **** typedef my_memory_mgr * my_mem_ptr;
 142:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 143:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 144:fltk-1.3.4-1/jpeg/jmemmgr.c **** /*
 145:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * The control blocks for virtual arrays.
 146:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * Note that these blocks are allocated in the "small" pool area.
 147:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * System-dependent info for the associated backing store (if any) is hidden
 148:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * inside the backing_store_info struct.
 149:fltk-1.3.4-1/jpeg/jmemmgr.c ****  */
 150:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 151:fltk-1.3.4-1/jpeg/jmemmgr.c **** struct jvirt_sarray_control {
 152:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JSAMPARRAY mem_buffer;	/* => the in-memory buffer */
 153:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JDIMENSION rows_in_array;	/* total virtual array height */
 154:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JDIMENSION samplesperrow;	/* width of array (and of memory buffer) */
 155:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JDIMENSION maxaccess;		/* max rows accessed by access_virt_sarray */
 156:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JDIMENSION rows_in_mem;	/* height of memory buffer */
 157:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JDIMENSION rowsperchunk;	/* allocation chunk size in mem_buffer */
 158:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JDIMENSION cur_start_row;	/* first logical row # in the buffer */
 159:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JDIMENSION first_undef_row;	/* row # of first uninitialized row */
 160:fltk-1.3.4-1/jpeg/jmemmgr.c ****   boolean pre_zero;		/* pre-zero mode requested? */
 161:fltk-1.3.4-1/jpeg/jmemmgr.c ****   boolean dirty;		/* do current buffer contents need written? */
 162:fltk-1.3.4-1/jpeg/jmemmgr.c ****   boolean b_s_open;		/* is backing-store data valid? */
 163:fltk-1.3.4-1/jpeg/jmemmgr.c ****   jvirt_sarray_ptr next;	/* link to next virtual sarray control block */
 164:fltk-1.3.4-1/jpeg/jmemmgr.c ****   backing_store_info b_s_info;	/* System-dependent control info */
 165:fltk-1.3.4-1/jpeg/jmemmgr.c **** };
 166:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 167:fltk-1.3.4-1/jpeg/jmemmgr.c **** struct jvirt_barray_control {
 168:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JBLOCKARRAY mem_buffer;	/* => the in-memory buffer */
 169:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JDIMENSION rows_in_array;	/* total virtual array height */
 170:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JDIMENSION blocksperrow;	/* width of array (and of memory buffer) */
 171:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JDIMENSION maxaccess;		/* max rows accessed by access_virt_barray */
 172:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JDIMENSION rows_in_mem;	/* height of memory buffer */
 173:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JDIMENSION rowsperchunk;	/* allocation chunk size in mem_buffer */
 174:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JDIMENSION cur_start_row;	/* first logical row # in the buffer */
 175:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JDIMENSION first_undef_row;	/* row # of first uninitialized row */
 176:fltk-1.3.4-1/jpeg/jmemmgr.c ****   boolean pre_zero;		/* pre-zero mode requested? */
 177:fltk-1.3.4-1/jpeg/jmemmgr.c ****   boolean dirty;		/* do current buffer contents need written? */
 178:fltk-1.3.4-1/jpeg/jmemmgr.c ****   boolean b_s_open;		/* is backing-store data valid? */
 179:fltk-1.3.4-1/jpeg/jmemmgr.c ****   jvirt_barray_ptr next;	/* link to next virtual barray control block */
 180:fltk-1.3.4-1/jpeg/jmemmgr.c ****   backing_store_info b_s_info;	/* System-dependent control info */
 181:fltk-1.3.4-1/jpeg/jmemmgr.c **** };
 182:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 183:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 184:fltk-1.3.4-1/jpeg/jmemmgr.c **** #ifdef MEM_STATS		/* optional extra stuff for statistics */
 185:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 186:fltk-1.3.4-1/jpeg/jmemmgr.c **** LOCAL(void)
 187:fltk-1.3.4-1/jpeg/jmemmgr.c **** print_mem_stats (j_common_ptr cinfo, int pool_id)
 188:fltk-1.3.4-1/jpeg/jmemmgr.c **** {
 189:fltk-1.3.4-1/jpeg/jmemmgr.c ****   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 190:fltk-1.3.4-1/jpeg/jmemmgr.c ****   small_pool_ptr shdr_ptr;
 191:fltk-1.3.4-1/jpeg/jmemmgr.c ****   large_pool_ptr lhdr_ptr;
 192:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 193:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Since this is only a debugging stub, we can cheat a little by using
 194:fltk-1.3.4-1/jpeg/jmemmgr.c ****    * fprintf directly rather than going through the trace message code.
 195:fltk-1.3.4-1/jpeg/jmemmgr.c ****    * This is helpful because message parm array can't handle longs.
 196:fltk-1.3.4-1/jpeg/jmemmgr.c ****    */
 197:fltk-1.3.4-1/jpeg/jmemmgr.c ****   fprintf(stderr, "Freeing pool %d, total space = %ld\n",
 198:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	  pool_id, mem->total_space_allocated);
 199:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 200:fltk-1.3.4-1/jpeg/jmemmgr.c ****   for (lhdr_ptr = mem->large_list[pool_id]; lhdr_ptr != NULL;
 201:fltk-1.3.4-1/jpeg/jmemmgr.c ****        lhdr_ptr = lhdr_ptr->hdr.next) {
 202:fltk-1.3.4-1/jpeg/jmemmgr.c ****     fprintf(stderr, "  Large chunk used %ld\n",
 203:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	    (long) lhdr_ptr->hdr.bytes_used);
 204:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
 205:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 206:fltk-1.3.4-1/jpeg/jmemmgr.c ****   for (shdr_ptr = mem->small_list[pool_id]; shdr_ptr != NULL;
 207:fltk-1.3.4-1/jpeg/jmemmgr.c ****        shdr_ptr = shdr_ptr->hdr.next) {
 208:fltk-1.3.4-1/jpeg/jmemmgr.c ****     fprintf(stderr, "  Small chunk used %ld free %ld\n",
 209:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	    (long) shdr_ptr->hdr.bytes_used,
 210:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	    (long) shdr_ptr->hdr.bytes_left);
 211:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
 212:fltk-1.3.4-1/jpeg/jmemmgr.c **** }
 213:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 214:fltk-1.3.4-1/jpeg/jmemmgr.c **** #endif /* MEM_STATS */
 215:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 216:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 217:fltk-1.3.4-1/jpeg/jmemmgr.c **** LOCAL(noreturn_t)
 218:fltk-1.3.4-1/jpeg/jmemmgr.c **** out_of_memory (j_common_ptr cinfo, int which)
 219:fltk-1.3.4-1/jpeg/jmemmgr.c **** /* Report an out-of-memory error and stop execution */
 220:fltk-1.3.4-1/jpeg/jmemmgr.c **** /* If we compiled MEM_STATS support, report alloc requests before dying */
 221:fltk-1.3.4-1/jpeg/jmemmgr.c **** {
 222:fltk-1.3.4-1/jpeg/jmemmgr.c **** #ifdef MEM_STATS
 223:fltk-1.3.4-1/jpeg/jmemmgr.c ****   cinfo->err->trace_level = 2;	/* force self_destruct to report stats */
 224:fltk-1.3.4-1/jpeg/jmemmgr.c **** #endif
 225:fltk-1.3.4-1/jpeg/jmemmgr.c ****   ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, which);
 226:fltk-1.3.4-1/jpeg/jmemmgr.c **** }
 227:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 228:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 229:fltk-1.3.4-1/jpeg/jmemmgr.c **** /*
 230:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * Allocation of "small" objects.
 231:fltk-1.3.4-1/jpeg/jmemmgr.c ****  *
 232:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * For these, we use pooled storage.  When a new pool must be created,
 233:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * we try to get enough space for the current request plus a "slop" factor,
 234:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * where the slop will be the amount of leftover space in the new pool.
 235:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * The speed vs. space tradeoff is largely determined by the slop values.
 236:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * A different slop value is provided for each pool class (lifetime),
 237:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * and we also distinguish the first pool of a class from later ones.
 238:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * NOTE: the values given work fairly well on both 16- and 32-bit-int
 239:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * machines, but may be too small if longs are 64 bits or more.
 240:fltk-1.3.4-1/jpeg/jmemmgr.c ****  */
 241:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 242:fltk-1.3.4-1/jpeg/jmemmgr.c **** static const size_t first_pool_slop[JPOOL_NUMPOOLS] = 
 243:fltk-1.3.4-1/jpeg/jmemmgr.c **** {
 244:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	1600,			/* first PERMANENT pool */
 245:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	16000			/* first IMAGE pool */
 246:fltk-1.3.4-1/jpeg/jmemmgr.c **** };
 247:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 248:fltk-1.3.4-1/jpeg/jmemmgr.c **** static const size_t extra_pool_slop[JPOOL_NUMPOOLS] = 
 249:fltk-1.3.4-1/jpeg/jmemmgr.c **** {
 250:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	0,			/* additional PERMANENT pools */
 251:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	5000			/* additional IMAGE pools */
 252:fltk-1.3.4-1/jpeg/jmemmgr.c **** };
 253:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 254:fltk-1.3.4-1/jpeg/jmemmgr.c **** #define MIN_SLOP  50		/* greater than 0 to avoid futile looping */
 255:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 256:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 257:fltk-1.3.4-1/jpeg/jmemmgr.c **** METHODDEF(void *)
 258:fltk-1.3.4-1/jpeg/jmemmgr.c **** alloc_small (j_common_ptr cinfo, int pool_id, size_t sizeofobject)
 259:fltk-1.3.4-1/jpeg/jmemmgr.c **** /* Allocate a "small" object */
 260:fltk-1.3.4-1/jpeg/jmemmgr.c **** {
 261:fltk-1.3.4-1/jpeg/jmemmgr.c ****   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 262:fltk-1.3.4-1/jpeg/jmemmgr.c ****   small_pool_ptr hdr_ptr, prev_hdr_ptr;
 263:fltk-1.3.4-1/jpeg/jmemmgr.c ****   char * data_ptr;
 264:fltk-1.3.4-1/jpeg/jmemmgr.c ****   size_t odd_bytes, min_request, slop;
 265:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 266:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Check for unsatisfiable request (do now to ensure no overflow below) */
 267:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (sizeofobject > (size_t) (MAX_ALLOC_CHUNK-SIZEOF(small_pool_hdr)))
 268:fltk-1.3.4-1/jpeg/jmemmgr.c ****     out_of_memory(cinfo, 1);	/* request exceeds malloc's ability */
 269:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 270:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
 271:fltk-1.3.4-1/jpeg/jmemmgr.c ****   odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
 272:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (odd_bytes > 0)
 273:fltk-1.3.4-1/jpeg/jmemmgr.c ****     sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
 274:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 275:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* See if space is available in any existing pool */
 276:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
 277:fltk-1.3.4-1/jpeg/jmemmgr.c ****     ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
 278:fltk-1.3.4-1/jpeg/jmemmgr.c ****   prev_hdr_ptr = NULL;
 279:fltk-1.3.4-1/jpeg/jmemmgr.c ****   hdr_ptr = mem->small_list[pool_id];
 280:fltk-1.3.4-1/jpeg/jmemmgr.c ****   while (hdr_ptr != NULL) {
 281:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (hdr_ptr->hdr.bytes_left >= sizeofobject)
 282:fltk-1.3.4-1/jpeg/jmemmgr.c ****       break;			/* found pool with enough space */
 283:fltk-1.3.4-1/jpeg/jmemmgr.c ****     prev_hdr_ptr = hdr_ptr;
 284:fltk-1.3.4-1/jpeg/jmemmgr.c ****     hdr_ptr = hdr_ptr->hdr.next;
 285:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
 286:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 287:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Time to make a new pool? */
 288:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (hdr_ptr == NULL) {
 289:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* min_request is what we need now, slop is what will be leftover */
 290:fltk-1.3.4-1/jpeg/jmemmgr.c ****     min_request = sizeofobject + SIZEOF(small_pool_hdr);
 291:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (prev_hdr_ptr == NULL)	/* first pool in class? */
 292:fltk-1.3.4-1/jpeg/jmemmgr.c ****       slop = first_pool_slop[pool_id];
 293:fltk-1.3.4-1/jpeg/jmemmgr.c ****     else
 294:fltk-1.3.4-1/jpeg/jmemmgr.c ****       slop = extra_pool_slop[pool_id];
 295:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Don't ask for more than MAX_ALLOC_CHUNK */
 296:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (slop > (size_t) (MAX_ALLOC_CHUNK-min_request))
 297:fltk-1.3.4-1/jpeg/jmemmgr.c ****       slop = (size_t) (MAX_ALLOC_CHUNK-min_request);
 298:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Try to get space, if fail reduce slop and try again */
 299:fltk-1.3.4-1/jpeg/jmemmgr.c ****     for (;;) {
 300:fltk-1.3.4-1/jpeg/jmemmgr.c ****       hdr_ptr = (small_pool_ptr) jpeg_get_small(cinfo, min_request + slop);
 301:fltk-1.3.4-1/jpeg/jmemmgr.c ****       if (hdr_ptr != NULL)
 302:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	break;
 303:fltk-1.3.4-1/jpeg/jmemmgr.c ****       slop /= 2;
 304:fltk-1.3.4-1/jpeg/jmemmgr.c ****       if (slop < MIN_SLOP)	/* give up when it gets real small */
 305:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	out_of_memory(cinfo, 2); /* jpeg_get_small failed */
 306:fltk-1.3.4-1/jpeg/jmemmgr.c ****     }
 307:fltk-1.3.4-1/jpeg/jmemmgr.c ****     mem->total_space_allocated += min_request + slop;
 308:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Success, initialize the new pool header and add to end of list */
 309:fltk-1.3.4-1/jpeg/jmemmgr.c ****     hdr_ptr->hdr.next = NULL;
 310:fltk-1.3.4-1/jpeg/jmemmgr.c ****     hdr_ptr->hdr.bytes_used = 0;
 311:fltk-1.3.4-1/jpeg/jmemmgr.c ****     hdr_ptr->hdr.bytes_left = sizeofobject + slop;
 312:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (prev_hdr_ptr == NULL)	/* first pool in class? */
 313:fltk-1.3.4-1/jpeg/jmemmgr.c ****       mem->small_list[pool_id] = hdr_ptr;
 314:fltk-1.3.4-1/jpeg/jmemmgr.c ****     else
 315:fltk-1.3.4-1/jpeg/jmemmgr.c ****       prev_hdr_ptr->hdr.next = hdr_ptr;
 316:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
 317:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 318:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* OK, allocate the object from the current pool */
 319:fltk-1.3.4-1/jpeg/jmemmgr.c ****   data_ptr = (char *) (hdr_ptr + 1); /* point to first data byte in pool */
 320:fltk-1.3.4-1/jpeg/jmemmgr.c ****   data_ptr += hdr_ptr->hdr.bytes_used; /* point to place for object */
 321:fltk-1.3.4-1/jpeg/jmemmgr.c ****   hdr_ptr->hdr.bytes_used += sizeofobject;
 322:fltk-1.3.4-1/jpeg/jmemmgr.c ****   hdr_ptr->hdr.bytes_left -= sizeofobject;
 323:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 324:fltk-1.3.4-1/jpeg/jmemmgr.c ****   return (void *) data_ptr;
 325:fltk-1.3.4-1/jpeg/jmemmgr.c **** }
 326:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 327:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 328:fltk-1.3.4-1/jpeg/jmemmgr.c **** /*
 329:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * Allocation of "large" objects.
 330:fltk-1.3.4-1/jpeg/jmemmgr.c ****  *
 331:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * The external semantics of these are the same as "small" objects,
 332:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * except that FAR pointers are used on 80x86.  However the pool
 333:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * management heuristics are quite different.  We assume that each
 334:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * request is large enough that it may as well be passed directly to
 335:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * jpeg_get_large; the pool management just links everything together
 336:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * so that we can free it all on demand.
 337:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * Note: the major use of "large" objects is in JSAMPARRAY and JBLOCKARRAY
 338:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * structures.  The routines that create these structures (see below)
 339:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * deliberately bunch rows together to ensure a large request size.
 340:fltk-1.3.4-1/jpeg/jmemmgr.c ****  */
 341:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 342:fltk-1.3.4-1/jpeg/jmemmgr.c **** METHODDEF(void FAR *)
 343:fltk-1.3.4-1/jpeg/jmemmgr.c **** alloc_large (j_common_ptr cinfo, int pool_id, size_t sizeofobject)
 344:fltk-1.3.4-1/jpeg/jmemmgr.c **** /* Allocate a "large" object */
 345:fltk-1.3.4-1/jpeg/jmemmgr.c **** {
 346:fltk-1.3.4-1/jpeg/jmemmgr.c ****   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 347:fltk-1.3.4-1/jpeg/jmemmgr.c ****   large_pool_ptr hdr_ptr;
 348:fltk-1.3.4-1/jpeg/jmemmgr.c ****   size_t odd_bytes;
 349:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 350:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Check for unsatisfiable request (do now to ensure no overflow below) */
 351:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (sizeofobject > (size_t) (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)))
 352:fltk-1.3.4-1/jpeg/jmemmgr.c ****     out_of_memory(cinfo, 3);	/* request exceeds malloc's ability */
 353:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 354:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
 355:fltk-1.3.4-1/jpeg/jmemmgr.c ****   odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
 356:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (odd_bytes > 0)
 357:fltk-1.3.4-1/jpeg/jmemmgr.c ****     sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
 358:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 359:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Always make a new pool */
 360:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
 361:fltk-1.3.4-1/jpeg/jmemmgr.c ****     ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
 362:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 363:fltk-1.3.4-1/jpeg/jmemmgr.c ****   hdr_ptr = (large_pool_ptr) jpeg_get_large(cinfo, sizeofobject +
 364:fltk-1.3.4-1/jpeg/jmemmgr.c **** 					    SIZEOF(large_pool_hdr));
 365:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (hdr_ptr == NULL)
 366:fltk-1.3.4-1/jpeg/jmemmgr.c ****     out_of_memory(cinfo, 4);	/* jpeg_get_large failed */
 367:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->total_space_allocated += sizeofobject + SIZEOF(large_pool_hdr);
 368:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 369:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Success, initialize the new pool header and add to list */
 370:fltk-1.3.4-1/jpeg/jmemmgr.c ****   hdr_ptr->hdr.next = mem->large_list[pool_id];
 371:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* We maintain space counts in each pool header for statistical purposes,
 372:fltk-1.3.4-1/jpeg/jmemmgr.c ****    * even though they are not needed for allocation.
 373:fltk-1.3.4-1/jpeg/jmemmgr.c ****    */
 374:fltk-1.3.4-1/jpeg/jmemmgr.c ****   hdr_ptr->hdr.bytes_used = sizeofobject;
 375:fltk-1.3.4-1/jpeg/jmemmgr.c ****   hdr_ptr->hdr.bytes_left = 0;
 376:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->large_list[pool_id] = hdr_ptr;
 377:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 378:fltk-1.3.4-1/jpeg/jmemmgr.c ****   return (void FAR *) (hdr_ptr + 1); /* point to first data byte in pool */
 379:fltk-1.3.4-1/jpeg/jmemmgr.c **** }
 380:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 381:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 382:fltk-1.3.4-1/jpeg/jmemmgr.c **** /*
 383:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * Creation of 2-D sample arrays.
 384:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * The pointers are in near heap, the samples themselves in FAR heap.
 385:fltk-1.3.4-1/jpeg/jmemmgr.c ****  *
 386:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * To minimize allocation overhead and to allow I/O of large contiguous
 387:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * blocks, we allocate the sample rows in groups of as many rows as possible
 388:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * without exceeding MAX_ALLOC_CHUNK total bytes per allocation request.
 389:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * NB: the virtual array control routines, later in this file, know about
 390:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * this chunking of rows.  The rowsperchunk value is left in the mem manager
 391:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * object so that it can be saved away if this sarray is the workspace for
 392:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * a virtual array.
 393:fltk-1.3.4-1/jpeg/jmemmgr.c ****  */
 394:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 395:fltk-1.3.4-1/jpeg/jmemmgr.c **** METHODDEF(JSAMPARRAY)
 396:fltk-1.3.4-1/jpeg/jmemmgr.c **** alloc_sarray (j_common_ptr cinfo, int pool_id,
 397:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	      JDIMENSION samplesperrow, JDIMENSION numrows)
 398:fltk-1.3.4-1/jpeg/jmemmgr.c **** /* Allocate a 2-D sample array */
 399:fltk-1.3.4-1/jpeg/jmemmgr.c **** {
 400:fltk-1.3.4-1/jpeg/jmemmgr.c ****   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 401:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JSAMPARRAY result;
 402:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JSAMPROW workspace;
 403:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JDIMENSION rowsperchunk, currow, i;
 404:fltk-1.3.4-1/jpeg/jmemmgr.c ****   long ltemp;
 405:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 406:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Calculate max # of rows allowed in one allocation chunk */
 407:fltk-1.3.4-1/jpeg/jmemmgr.c ****   ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
 408:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	  ((long) samplesperrow * SIZEOF(JSAMPLE));
 409:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (ltemp <= 0)
 410:fltk-1.3.4-1/jpeg/jmemmgr.c ****     ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
 411:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (ltemp < (long) numrows)
 412:fltk-1.3.4-1/jpeg/jmemmgr.c ****     rowsperchunk = (JDIMENSION) ltemp;
 413:fltk-1.3.4-1/jpeg/jmemmgr.c ****   else
 414:fltk-1.3.4-1/jpeg/jmemmgr.c ****     rowsperchunk = numrows;
 415:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->last_rowsperchunk = rowsperchunk;
 416:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 417:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Get space for row pointers (small object) */
 418:fltk-1.3.4-1/jpeg/jmemmgr.c ****   result = (JSAMPARRAY) alloc_small(cinfo, pool_id,
 419:fltk-1.3.4-1/jpeg/jmemmgr.c **** 				    (size_t) (numrows * SIZEOF(JSAMPROW)));
 420:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 421:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Get the rows themselves (large objects) */
 422:fltk-1.3.4-1/jpeg/jmemmgr.c ****   currow = 0;
 423:fltk-1.3.4-1/jpeg/jmemmgr.c ****   while (currow < numrows) {
 424:fltk-1.3.4-1/jpeg/jmemmgr.c ****     rowsperchunk = MIN(rowsperchunk, numrows - currow);
 425:fltk-1.3.4-1/jpeg/jmemmgr.c ****     workspace = (JSAMPROW) alloc_large(cinfo, pool_id,
 426:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	(size_t) ((size_t) rowsperchunk * (size_t) samplesperrow
 427:fltk-1.3.4-1/jpeg/jmemmgr.c **** 		  * SIZEOF(JSAMPLE)));
 428:fltk-1.3.4-1/jpeg/jmemmgr.c ****     for (i = rowsperchunk; i > 0; i--) {
 429:fltk-1.3.4-1/jpeg/jmemmgr.c ****       result[currow++] = workspace;
 430:fltk-1.3.4-1/jpeg/jmemmgr.c ****       workspace += samplesperrow;
 431:fltk-1.3.4-1/jpeg/jmemmgr.c ****     }
 432:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
 433:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 434:fltk-1.3.4-1/jpeg/jmemmgr.c ****   return result;
 435:fltk-1.3.4-1/jpeg/jmemmgr.c **** }
 436:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 437:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 438:fltk-1.3.4-1/jpeg/jmemmgr.c **** /*
 439:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * Creation of 2-D coefficient-block arrays.
 440:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * This is essentially the same as the code for sample arrays, above.
 441:fltk-1.3.4-1/jpeg/jmemmgr.c ****  */
 442:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 443:fltk-1.3.4-1/jpeg/jmemmgr.c **** METHODDEF(JBLOCKARRAY)
 444:fltk-1.3.4-1/jpeg/jmemmgr.c **** alloc_barray (j_common_ptr cinfo, int pool_id,
 445:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	      JDIMENSION blocksperrow, JDIMENSION numrows)
 446:fltk-1.3.4-1/jpeg/jmemmgr.c **** /* Allocate a 2-D coefficient-block array */
 447:fltk-1.3.4-1/jpeg/jmemmgr.c **** {
 448:fltk-1.3.4-1/jpeg/jmemmgr.c ****   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 449:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JBLOCKARRAY result;
 450:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JBLOCKROW workspace;
 451:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JDIMENSION rowsperchunk, currow, i;
 452:fltk-1.3.4-1/jpeg/jmemmgr.c ****   long ltemp;
 453:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 454:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Calculate max # of rows allowed in one allocation chunk */
 455:fltk-1.3.4-1/jpeg/jmemmgr.c ****   ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
 456:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	  ((long) blocksperrow * SIZEOF(JBLOCK));
 457:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (ltemp <= 0)
 458:fltk-1.3.4-1/jpeg/jmemmgr.c ****     ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
 459:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (ltemp < (long) numrows)
 460:fltk-1.3.4-1/jpeg/jmemmgr.c ****     rowsperchunk = (JDIMENSION) ltemp;
 461:fltk-1.3.4-1/jpeg/jmemmgr.c ****   else
 462:fltk-1.3.4-1/jpeg/jmemmgr.c ****     rowsperchunk = numrows;
 463:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->last_rowsperchunk = rowsperchunk;
 464:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 465:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Get space for row pointers (small object) */
 466:fltk-1.3.4-1/jpeg/jmemmgr.c ****   result = (JBLOCKARRAY) alloc_small(cinfo, pool_id,
 467:fltk-1.3.4-1/jpeg/jmemmgr.c **** 				     (size_t) (numrows * SIZEOF(JBLOCKROW)));
 468:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 469:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Get the rows themselves (large objects) */
 470:fltk-1.3.4-1/jpeg/jmemmgr.c ****   currow = 0;
 471:fltk-1.3.4-1/jpeg/jmemmgr.c ****   while (currow < numrows) {
 472:fltk-1.3.4-1/jpeg/jmemmgr.c ****     rowsperchunk = MIN(rowsperchunk, numrows - currow);
 473:fltk-1.3.4-1/jpeg/jmemmgr.c ****     workspace = (JBLOCKROW) alloc_large(cinfo, pool_id,
 474:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	(size_t) ((size_t) rowsperchunk * (size_t) blocksperrow
 475:fltk-1.3.4-1/jpeg/jmemmgr.c **** 		  * SIZEOF(JBLOCK)));
 476:fltk-1.3.4-1/jpeg/jmemmgr.c ****     for (i = rowsperchunk; i > 0; i--) {
 477:fltk-1.3.4-1/jpeg/jmemmgr.c ****       result[currow++] = workspace;
 478:fltk-1.3.4-1/jpeg/jmemmgr.c ****       workspace += blocksperrow;
 479:fltk-1.3.4-1/jpeg/jmemmgr.c ****     }
 480:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
 481:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 482:fltk-1.3.4-1/jpeg/jmemmgr.c ****   return result;
 483:fltk-1.3.4-1/jpeg/jmemmgr.c **** }
 484:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 485:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 486:fltk-1.3.4-1/jpeg/jmemmgr.c **** /*
 487:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * About virtual array management:
 488:fltk-1.3.4-1/jpeg/jmemmgr.c ****  *
 489:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * The above "normal" array routines are only used to allocate strip buffers
 490:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * (as wide as the image, but just a few rows high).  Full-image-sized buffers
 491:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * are handled as "virtual" arrays.  The array is still accessed a strip at a
 492:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * time, but the memory manager must save the whole array for repeated
 493:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * accesses.  The intended implementation is that there is a strip buffer in
 494:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * memory (as high as is possible given the desired memory limit), plus a
 495:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * backing file that holds the rest of the array.
 496:fltk-1.3.4-1/jpeg/jmemmgr.c ****  *
 497:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * The request_virt_array routines are told the total size of the image and
 498:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * the maximum number of rows that will be accessed at once.  The in-memory
 499:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * buffer must be at least as large as the maxaccess value.
 500:fltk-1.3.4-1/jpeg/jmemmgr.c ****  *
 501:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * The request routines create control blocks but not the in-memory buffers.
 502:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * That is postponed until realize_virt_arrays is called.  At that time the
 503:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * total amount of space needed is known (approximately, anyway), so free
 504:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * memory can be divided up fairly.
 505:fltk-1.3.4-1/jpeg/jmemmgr.c ****  *
 506:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * The access_virt_array routines are responsible for making a specific strip
 507:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * area accessible (after reading or writing the backing file, if necessary).
 508:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * Note that the access routines are told whether the caller intends to modify
 509:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * the accessed strip; during a read-only pass this saves having to rewrite
 510:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * data to disk.  The access routines are also responsible for pre-zeroing
 511:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * any newly accessed rows, if pre-zeroing was requested.
 512:fltk-1.3.4-1/jpeg/jmemmgr.c ****  *
 513:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * In current usage, the access requests are usually for nonoverlapping
 514:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * strips; that is, successive access start_row numbers differ by exactly
 515:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * num_rows = maxaccess.  This means we can get good performance with simple
 516:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * buffer dump/reload logic, by making the in-memory buffer be a multiple
 517:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * of the access height; then there will never be accesses across bufferload
 518:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * boundaries.  The code will still work with overlapping access requests,
 519:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * but it doesn't handle bufferload overlaps very efficiently.
 520:fltk-1.3.4-1/jpeg/jmemmgr.c ****  */
 521:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 522:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 523:fltk-1.3.4-1/jpeg/jmemmgr.c **** METHODDEF(jvirt_sarray_ptr)
 524:fltk-1.3.4-1/jpeg/jmemmgr.c **** request_virt_sarray (j_common_ptr cinfo, int pool_id, boolean pre_zero,
 525:fltk-1.3.4-1/jpeg/jmemmgr.c **** 		     JDIMENSION samplesperrow, JDIMENSION numrows,
 526:fltk-1.3.4-1/jpeg/jmemmgr.c **** 		     JDIMENSION maxaccess)
 527:fltk-1.3.4-1/jpeg/jmemmgr.c **** /* Request a virtual 2-D sample array */
 528:fltk-1.3.4-1/jpeg/jmemmgr.c **** {
 529:fltk-1.3.4-1/jpeg/jmemmgr.c ****   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 530:fltk-1.3.4-1/jpeg/jmemmgr.c ****   jvirt_sarray_ptr result;
 531:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 532:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Only IMAGE-lifetime virtual arrays are currently supported */
 533:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (pool_id != JPOOL_IMAGE)
 534:fltk-1.3.4-1/jpeg/jmemmgr.c ****     ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
 535:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 536:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* get control block */
 537:fltk-1.3.4-1/jpeg/jmemmgr.c ****   result = (jvirt_sarray_ptr) alloc_small(cinfo, pool_id,
 538:fltk-1.3.4-1/jpeg/jmemmgr.c **** 					  SIZEOF(struct jvirt_sarray_control));
 539:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 540:fltk-1.3.4-1/jpeg/jmemmgr.c ****   result->mem_buffer = NULL;	/* marks array not yet realized */
 541:fltk-1.3.4-1/jpeg/jmemmgr.c ****   result->rows_in_array = numrows;
 542:fltk-1.3.4-1/jpeg/jmemmgr.c ****   result->samplesperrow = samplesperrow;
 543:fltk-1.3.4-1/jpeg/jmemmgr.c ****   result->maxaccess = maxaccess;
 544:fltk-1.3.4-1/jpeg/jmemmgr.c ****   result->pre_zero = pre_zero;
 545:fltk-1.3.4-1/jpeg/jmemmgr.c ****   result->b_s_open = FALSE;	/* no associated backing-store object */
 546:fltk-1.3.4-1/jpeg/jmemmgr.c ****   result->next = mem->virt_sarray_list; /* add to list of virtual arrays */
 547:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->virt_sarray_list = result;
 548:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 549:fltk-1.3.4-1/jpeg/jmemmgr.c ****   return result;
 550:fltk-1.3.4-1/jpeg/jmemmgr.c **** }
 551:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 552:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 553:fltk-1.3.4-1/jpeg/jmemmgr.c **** METHODDEF(jvirt_barray_ptr)
 554:fltk-1.3.4-1/jpeg/jmemmgr.c **** request_virt_barray (j_common_ptr cinfo, int pool_id, boolean pre_zero,
 555:fltk-1.3.4-1/jpeg/jmemmgr.c **** 		     JDIMENSION blocksperrow, JDIMENSION numrows,
 556:fltk-1.3.4-1/jpeg/jmemmgr.c **** 		     JDIMENSION maxaccess)
 557:fltk-1.3.4-1/jpeg/jmemmgr.c **** /* Request a virtual 2-D coefficient-block array */
 558:fltk-1.3.4-1/jpeg/jmemmgr.c **** {
 559:fltk-1.3.4-1/jpeg/jmemmgr.c ****   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 560:fltk-1.3.4-1/jpeg/jmemmgr.c ****   jvirt_barray_ptr result;
 561:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 562:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Only IMAGE-lifetime virtual arrays are currently supported */
 563:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (pool_id != JPOOL_IMAGE)
 564:fltk-1.3.4-1/jpeg/jmemmgr.c ****     ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
 565:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 566:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* get control block */
 567:fltk-1.3.4-1/jpeg/jmemmgr.c ****   result = (jvirt_barray_ptr) alloc_small(cinfo, pool_id,
 568:fltk-1.3.4-1/jpeg/jmemmgr.c **** 					  SIZEOF(struct jvirt_barray_control));
 569:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 570:fltk-1.3.4-1/jpeg/jmemmgr.c ****   result->mem_buffer = NULL;	/* marks array not yet realized */
 571:fltk-1.3.4-1/jpeg/jmemmgr.c ****   result->rows_in_array = numrows;
 572:fltk-1.3.4-1/jpeg/jmemmgr.c ****   result->blocksperrow = blocksperrow;
 573:fltk-1.3.4-1/jpeg/jmemmgr.c ****   result->maxaccess = maxaccess;
 574:fltk-1.3.4-1/jpeg/jmemmgr.c ****   result->pre_zero = pre_zero;
 575:fltk-1.3.4-1/jpeg/jmemmgr.c ****   result->b_s_open = FALSE;	/* no associated backing-store object */
 576:fltk-1.3.4-1/jpeg/jmemmgr.c ****   result->next = mem->virt_barray_list; /* add to list of virtual arrays */
 577:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->virt_barray_list = result;
 578:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 579:fltk-1.3.4-1/jpeg/jmemmgr.c ****   return result;
 580:fltk-1.3.4-1/jpeg/jmemmgr.c **** }
 581:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 582:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 583:fltk-1.3.4-1/jpeg/jmemmgr.c **** METHODDEF(void)
 584:fltk-1.3.4-1/jpeg/jmemmgr.c **** realize_virt_arrays (j_common_ptr cinfo)
 585:fltk-1.3.4-1/jpeg/jmemmgr.c **** /* Allocate the in-memory buffers for any unrealized virtual arrays */
 586:fltk-1.3.4-1/jpeg/jmemmgr.c **** {
 587:fltk-1.3.4-1/jpeg/jmemmgr.c ****   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 588:fltk-1.3.4-1/jpeg/jmemmgr.c ****   long space_per_minheight, maximum_space, avail_mem;
 589:fltk-1.3.4-1/jpeg/jmemmgr.c ****   long minheights, max_minheights;
 590:fltk-1.3.4-1/jpeg/jmemmgr.c ****   jvirt_sarray_ptr sptr;
 591:fltk-1.3.4-1/jpeg/jmemmgr.c ****   jvirt_barray_ptr bptr;
 592:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 593:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Compute the minimum space needed (maxaccess rows in each buffer)
 594:fltk-1.3.4-1/jpeg/jmemmgr.c ****    * and the maximum space needed (full image height in each buffer).
 595:fltk-1.3.4-1/jpeg/jmemmgr.c ****    * These may be of use to the system-dependent jpeg_mem_available routine.
 596:fltk-1.3.4-1/jpeg/jmemmgr.c ****    */
 597:fltk-1.3.4-1/jpeg/jmemmgr.c ****   space_per_minheight = 0;
 598:fltk-1.3.4-1/jpeg/jmemmgr.c ****   maximum_space = 0;
 599:fltk-1.3.4-1/jpeg/jmemmgr.c ****   for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
 600:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (sptr->mem_buffer == NULL) { /* if not realized yet */
 601:fltk-1.3.4-1/jpeg/jmemmgr.c ****       space_per_minheight += (long) sptr->maxaccess *
 602:fltk-1.3.4-1/jpeg/jmemmgr.c **** 			     (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
 603:fltk-1.3.4-1/jpeg/jmemmgr.c ****       maximum_space += (long) sptr->rows_in_array *
 604:fltk-1.3.4-1/jpeg/jmemmgr.c **** 		       (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
 605:fltk-1.3.4-1/jpeg/jmemmgr.c ****     }
 606:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
 607:fltk-1.3.4-1/jpeg/jmemmgr.c ****   for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
 608:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (bptr->mem_buffer == NULL) { /* if not realized yet */
 609:fltk-1.3.4-1/jpeg/jmemmgr.c ****       space_per_minheight += (long) bptr->maxaccess *
 610:fltk-1.3.4-1/jpeg/jmemmgr.c **** 			     (long) bptr->blocksperrow * SIZEOF(JBLOCK);
 611:fltk-1.3.4-1/jpeg/jmemmgr.c ****       maximum_space += (long) bptr->rows_in_array *
 612:fltk-1.3.4-1/jpeg/jmemmgr.c **** 		       (long) bptr->blocksperrow * SIZEOF(JBLOCK);
 613:fltk-1.3.4-1/jpeg/jmemmgr.c ****     }
 614:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
 615:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 616:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (space_per_minheight <= 0)
 617:fltk-1.3.4-1/jpeg/jmemmgr.c ****     return;			/* no unrealized arrays, no work */
 618:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 619:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Determine amount of memory to actually use; this is system-dependent. */
 620:fltk-1.3.4-1/jpeg/jmemmgr.c ****   avail_mem = jpeg_mem_available(cinfo, space_per_minheight, maximum_space,
 621:fltk-1.3.4-1/jpeg/jmemmgr.c **** 				 mem->total_space_allocated);
 622:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 623:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* If the maximum space needed is available, make all the buffers full
 624:fltk-1.3.4-1/jpeg/jmemmgr.c ****    * height; otherwise parcel it out with the same number of minheights
 625:fltk-1.3.4-1/jpeg/jmemmgr.c ****    * in each buffer.
 626:fltk-1.3.4-1/jpeg/jmemmgr.c ****    */
 627:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (avail_mem >= maximum_space)
 628:fltk-1.3.4-1/jpeg/jmemmgr.c ****     max_minheights = 1000000000L;
 629:fltk-1.3.4-1/jpeg/jmemmgr.c ****   else {
 630:fltk-1.3.4-1/jpeg/jmemmgr.c ****     max_minheights = avail_mem / space_per_minheight;
 631:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* If there doesn't seem to be enough space, try to get the minimum
 632:fltk-1.3.4-1/jpeg/jmemmgr.c ****      * anyway.  This allows a "stub" implementation of jpeg_mem_available().
 633:fltk-1.3.4-1/jpeg/jmemmgr.c ****      */
 634:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (max_minheights <= 0)
 635:fltk-1.3.4-1/jpeg/jmemmgr.c ****       max_minheights = 1;
 636:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
 637:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 638:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Allocate the in-memory buffers and initialize backing store as needed. */
 639:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 640:fltk-1.3.4-1/jpeg/jmemmgr.c ****   for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
 641:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (sptr->mem_buffer == NULL) { /* if not realized yet */
 642:fltk-1.3.4-1/jpeg/jmemmgr.c ****       minheights = ((long) sptr->rows_in_array - 1L) / sptr->maxaccess + 1L;
 643:fltk-1.3.4-1/jpeg/jmemmgr.c ****       if (minheights <= max_minheights) {
 644:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	/* This buffer fits in memory */
 645:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	sptr->rows_in_mem = sptr->rows_in_array;
 646:fltk-1.3.4-1/jpeg/jmemmgr.c ****       } else {
 647:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	/* It doesn't fit in memory, create backing store. */
 648:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	sptr->rows_in_mem = (JDIMENSION) (max_minheights * sptr->maxaccess);
 649:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	jpeg_open_backing_store(cinfo, & sptr->b_s_info,
 650:fltk-1.3.4-1/jpeg/jmemmgr.c **** 				(long) sptr->rows_in_array *
 651:fltk-1.3.4-1/jpeg/jmemmgr.c **** 				(long) sptr->samplesperrow *
 652:fltk-1.3.4-1/jpeg/jmemmgr.c **** 				(long) SIZEOF(JSAMPLE));
 653:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	sptr->b_s_open = TRUE;
 654:fltk-1.3.4-1/jpeg/jmemmgr.c ****       }
 655:fltk-1.3.4-1/jpeg/jmemmgr.c ****       sptr->mem_buffer = alloc_sarray(cinfo, JPOOL_IMAGE,
 656:fltk-1.3.4-1/jpeg/jmemmgr.c **** 				      sptr->samplesperrow, sptr->rows_in_mem);
 657:fltk-1.3.4-1/jpeg/jmemmgr.c ****       sptr->rowsperchunk = mem->last_rowsperchunk;
 658:fltk-1.3.4-1/jpeg/jmemmgr.c ****       sptr->cur_start_row = 0;
 659:fltk-1.3.4-1/jpeg/jmemmgr.c ****       sptr->first_undef_row = 0;
 660:fltk-1.3.4-1/jpeg/jmemmgr.c ****       sptr->dirty = FALSE;
 661:fltk-1.3.4-1/jpeg/jmemmgr.c ****     }
 662:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
 663:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 664:fltk-1.3.4-1/jpeg/jmemmgr.c ****   for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
 665:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (bptr->mem_buffer == NULL) { /* if not realized yet */
 666:fltk-1.3.4-1/jpeg/jmemmgr.c ****       minheights = ((long) bptr->rows_in_array - 1L) / bptr->maxaccess + 1L;
 667:fltk-1.3.4-1/jpeg/jmemmgr.c ****       if (minheights <= max_minheights) {
 668:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	/* This buffer fits in memory */
 669:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	bptr->rows_in_mem = bptr->rows_in_array;
 670:fltk-1.3.4-1/jpeg/jmemmgr.c ****       } else {
 671:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	/* It doesn't fit in memory, create backing store. */
 672:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	bptr->rows_in_mem = (JDIMENSION) (max_minheights * bptr->maxaccess);
 673:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	jpeg_open_backing_store(cinfo, & bptr->b_s_info,
 674:fltk-1.3.4-1/jpeg/jmemmgr.c **** 				(long) bptr->rows_in_array *
 675:fltk-1.3.4-1/jpeg/jmemmgr.c **** 				(long) bptr->blocksperrow *
 676:fltk-1.3.4-1/jpeg/jmemmgr.c **** 				(long) SIZEOF(JBLOCK));
 677:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	bptr->b_s_open = TRUE;
 678:fltk-1.3.4-1/jpeg/jmemmgr.c ****       }
 679:fltk-1.3.4-1/jpeg/jmemmgr.c ****       bptr->mem_buffer = alloc_barray(cinfo, JPOOL_IMAGE,
 680:fltk-1.3.4-1/jpeg/jmemmgr.c **** 				      bptr->blocksperrow, bptr->rows_in_mem);
 681:fltk-1.3.4-1/jpeg/jmemmgr.c ****       bptr->rowsperchunk = mem->last_rowsperchunk;
 682:fltk-1.3.4-1/jpeg/jmemmgr.c ****       bptr->cur_start_row = 0;
 683:fltk-1.3.4-1/jpeg/jmemmgr.c ****       bptr->first_undef_row = 0;
 684:fltk-1.3.4-1/jpeg/jmemmgr.c ****       bptr->dirty = FALSE;
 685:fltk-1.3.4-1/jpeg/jmemmgr.c ****     }
 686:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
 687:fltk-1.3.4-1/jpeg/jmemmgr.c **** }
 688:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 689:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 690:fltk-1.3.4-1/jpeg/jmemmgr.c **** LOCAL(void)
 691:fltk-1.3.4-1/jpeg/jmemmgr.c **** do_sarray_io (j_common_ptr cinfo, jvirt_sarray_ptr ptr, boolean writing)
 692:fltk-1.3.4-1/jpeg/jmemmgr.c **** /* Do backing store read or write of a virtual sample array */
 693:fltk-1.3.4-1/jpeg/jmemmgr.c **** {
 694:fltk-1.3.4-1/jpeg/jmemmgr.c ****   long bytesperrow, file_offset, byte_count, rows, thisrow, i;
 695:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 696:fltk-1.3.4-1/jpeg/jmemmgr.c ****   bytesperrow = (long) ptr->samplesperrow * SIZEOF(JSAMPLE);
 697:fltk-1.3.4-1/jpeg/jmemmgr.c ****   file_offset = ptr->cur_start_row * bytesperrow;
 698:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Loop to read or write each allocation chunk in mem_buffer */
 699:fltk-1.3.4-1/jpeg/jmemmgr.c ****   for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
 700:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* One chunk, but check for short chunk at end of buffer */
 701:fltk-1.3.4-1/jpeg/jmemmgr.c ****     rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);
 702:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Transfer no more than is currently defined */
 703:fltk-1.3.4-1/jpeg/jmemmgr.c ****     thisrow = (long) ptr->cur_start_row + i;
 704:fltk-1.3.4-1/jpeg/jmemmgr.c ****     rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
 705:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Transfer no more than fits in file */
 706:fltk-1.3.4-1/jpeg/jmemmgr.c ****     rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
 707:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (rows <= 0)		/* this chunk might be past end of file! */
 708:fltk-1.3.4-1/jpeg/jmemmgr.c ****       break;
 709:fltk-1.3.4-1/jpeg/jmemmgr.c ****     byte_count = rows * bytesperrow;
 710:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (writing)
 711:fltk-1.3.4-1/jpeg/jmemmgr.c ****       (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
 712:fltk-1.3.4-1/jpeg/jmemmgr.c **** 					    (void FAR *) ptr->mem_buffer[i],
 713:fltk-1.3.4-1/jpeg/jmemmgr.c **** 					    file_offset, byte_count);
 714:fltk-1.3.4-1/jpeg/jmemmgr.c ****     else
 715:fltk-1.3.4-1/jpeg/jmemmgr.c ****       (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
 716:fltk-1.3.4-1/jpeg/jmemmgr.c **** 					   (void FAR *) ptr->mem_buffer[i],
 717:fltk-1.3.4-1/jpeg/jmemmgr.c **** 					   file_offset, byte_count);
 718:fltk-1.3.4-1/jpeg/jmemmgr.c ****     file_offset += byte_count;
 719:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
 720:fltk-1.3.4-1/jpeg/jmemmgr.c **** }
 721:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 722:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 723:fltk-1.3.4-1/jpeg/jmemmgr.c **** LOCAL(void)
 724:fltk-1.3.4-1/jpeg/jmemmgr.c **** do_barray_io (j_common_ptr cinfo, jvirt_barray_ptr ptr, boolean writing)
 725:fltk-1.3.4-1/jpeg/jmemmgr.c **** /* Do backing store read or write of a virtual coefficient-block array */
 726:fltk-1.3.4-1/jpeg/jmemmgr.c **** {
  16              		.loc 1 726 0
  17              		.cfi_startproc
  18              	.LVL0:
  19 0000 4157     		pushq	%r15
  20              		.cfi_def_cfa_offset 16
  21              		.cfi_offset 15, -16
  22 0002 4156     		pushq	%r14
  23              		.cfi_def_cfa_offset 24
  24              		.cfi_offset 14, -24
  25 0004 4155     		pushq	%r13
  26              		.cfi_def_cfa_offset 32
  27              		.cfi_offset 13, -32
  28 0006 4154     		pushq	%r12
  29              		.cfi_def_cfa_offset 40
  30              		.cfi_offset 12, -40
  31 0008 55       		pushq	%rbp
  32              		.cfi_def_cfa_offset 48
  33              		.cfi_offset 6, -48
  34 0009 53       		pushq	%rbx
  35              		.cfi_def_cfa_offset 56
  36              		.cfi_offset 3, -56
  37 000a 4883EC18 		subq	$24, %rsp
  38              		.cfi_def_cfa_offset 80
 727:fltk-1.3.4-1/jpeg/jmemmgr.c ****   long bytesperrow, file_offset, byte_count, rows, thisrow, i;
 728:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 729:fltk-1.3.4-1/jpeg/jmemmgr.c ****   bytesperrow = (long) ptr->blocksperrow * SIZEOF(JBLOCK);
  39              		.loc 1 729 0
  40 000e 8B6E0C   		movl	12(%rsi), %ebp
 730:fltk-1.3.4-1/jpeg/jmemmgr.c ****   file_offset = ptr->cur_start_row * bytesperrow;
  41              		.loc 1 730 0
  42 0011 8B4E1C   		movl	28(%rsi), %ecx
 731:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Loop to read or write each allocation chunk in mem_buffer */
 732:fltk-1.3.4-1/jpeg/jmemmgr.c ****   for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
  43              		.loc 1 732 0
  44 0014 448B4614 		movl	20(%rsi), %r8d
 729:fltk-1.3.4-1/jpeg/jmemmgr.c ****   file_offset = ptr->cur_start_row * bytesperrow;
  45              		.loc 1 729 0
  46 0018 48C1E507 		salq	$7, %rbp
  47              	.LVL1:
 730:fltk-1.3.4-1/jpeg/jmemmgr.c ****   file_offset = ptr->cur_start_row * bytesperrow;
  48              		.loc 1 730 0
  49 001c 4989EE   		movq	%rbp, %r14
  50 001f 4C0FAFF1 		imulq	%rcx, %r14
  51              	.LVL2:
  52              		.loc 1 732 0
  53 0023 4D85C0   		testq	%r8, %r8
  54 0026 0F84C400 		je	.L1
  54      0000
 733:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* One chunk, but check for short chunk at end of buffer */
 734:fltk-1.3.4-1/jpeg/jmemmgr.c ****     rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);
  55              		.loc 1 734 0
  56 002c 8B4618   		movl	24(%rsi), %eax
  57 002f 4C39C0   		cmpq	%r8, %rax
  58 0032 490F4FC0 		cmovg	%r8, %rax
  59              	.LVL3:
 735:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Transfer no more than is currently defined */
 736:fltk-1.3.4-1/jpeg/jmemmgr.c ****     thisrow = (long) ptr->cur_start_row + i;
 737:fltk-1.3.4-1/jpeg/jmemmgr.c ****     rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
  60              		.loc 1 737 0
  61 0036 448B4620 		movl	32(%rsi), %r8d
  62 003a 4929C8   		subq	%rcx, %r8
  63 003d 4939C0   		cmpq	%rax, %r8
  64 0040 490F4EC0 		cmovle	%r8, %rax
  65              	.LVL4:
 738:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Transfer no more than fits in file */
 739:fltk-1.3.4-1/jpeg/jmemmgr.c ****     rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
  66              		.loc 1 739 0
  67 0044 448B4608 		movl	8(%rsi), %r8d
  68 0048 4929C8   		subq	%rcx, %r8
  69 004b 4939C0   		cmpq	%rax, %r8
  70 004e 4C0F4FC0 		cmovg	%rax, %r8
  71              	.LVL5:
 740:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (rows <= 0)		/* this chunk might be past end of file! */
  72              		.loc 1 740 0
  73 0052 4D85C0   		testq	%r8, %r8
  74 0055 0F8E9500 		jle	.L1
  74      0000
  75 005b 488D4638 		leaq	56(%rsi), %rax
  76 005f 4189D5   		movl	%edx, %r13d
  77 0062 4989F7   		movq	%rsi, %r15
  78 0065 48897C24 		movq	%rdi, 8(%rsp)
  78      08
  79 006a 4531E4   		xorl	%r12d, %r12d
  80 006d 48890424 		movq	%rax, (%rsp)
  81 0071 EB4E     		jmp	.L5
  82              	.LVL6:
  83              		.p2align 4,,10
  84 0073 0F1F4400 		.p2align 3
  84      00
  85              	.L11:
 741:fltk-1.3.4-1/jpeg/jmemmgr.c ****       break;
 742:fltk-1.3.4-1/jpeg/jmemmgr.c ****     byte_count = rows * bytesperrow;
 743:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (writing)
 744:fltk-1.3.4-1/jpeg/jmemmgr.c ****       (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
  86              		.loc 1 744 0
  87 0078 41FF5740 		call	*64(%r15)
  88              	.LVL7:
  89              	.L7:
 732:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* One chunk, but check for short chunk at end of buffer */
  90              		.loc 1 732 0 discriminator 2
  91 007c 418B5718 		movl	24(%r15), %edx
  92 0080 458B4714 		movl	20(%r15), %r8d
 745:fltk-1.3.4-1/jpeg/jmemmgr.c **** 					    (void FAR *) ptr->mem_buffer[i],
 746:fltk-1.3.4-1/jpeg/jmemmgr.c **** 					    file_offset, byte_count);
 747:fltk-1.3.4-1/jpeg/jmemmgr.c ****     else
 748:fltk-1.3.4-1/jpeg/jmemmgr.c ****       (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
 749:fltk-1.3.4-1/jpeg/jmemmgr.c **** 					   (void FAR *) ptr->mem_buffer[i],
 750:fltk-1.3.4-1/jpeg/jmemmgr.c **** 					   file_offset, byte_count);
 751:fltk-1.3.4-1/jpeg/jmemmgr.c ****     file_offset += byte_count;
  93              		.loc 1 751 0 discriminator 2
  94 0084 4901DE   		addq	%rbx, %r14
  95              	.LVL8:
 732:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* One chunk, but check for short chunk at end of buffer */
  96              		.loc 1 732 0 discriminator 2
  97 0087 4901D4   		addq	%rdx, %r12
  98              	.LVL9:
  99 008a 4D39E0   		cmpq	%r12, %r8
 100 008d 7E61     		jle	.L1
 734:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Transfer no more than is currently defined */
 101              		.loc 1 734 0
 102 008f 4D29E0   		subq	%r12, %r8
 736:fltk-1.3.4-1/jpeg/jmemmgr.c ****     rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
 103              		.loc 1 736 0
 104 0092 418B4F1C 		movl	28(%r15), %ecx
 734:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Transfer no more than is currently defined */
 105              		.loc 1 734 0
 106 0096 4939D0   		cmpq	%rdx, %r8
 107 0099 490F4ED0 		cmovle	%r8, %rdx
 108              	.LVL10:
 737:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Transfer no more than fits in file */
 109              		.loc 1 737 0
 110 009d 458B4720 		movl	32(%r15), %r8d
 736:fltk-1.3.4-1/jpeg/jmemmgr.c ****     rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
 111              		.loc 1 736 0
 112 00a1 4C01E1   		addq	%r12, %rcx
 113              	.LVL11:
 737:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Transfer no more than fits in file */
 114              		.loc 1 737 0
 115 00a4 4929C8   		subq	%rcx, %r8
 116 00a7 4939D0   		cmpq	%rdx, %r8
 117 00aa 490F4ED0 		cmovle	%r8, %rdx
 118              	.LVL12:
 739:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (rows <= 0)		/* this chunk might be past end of file! */
 119              		.loc 1 739 0
 120 00ae 458B4708 		movl	8(%r15), %r8d
 121 00b2 4929C8   		subq	%rcx, %r8
 122 00b5 4939D0   		cmpq	%rdx, %r8
 123 00b8 4C0F4FC2 		cmovg	%rdx, %r8
 124              	.LVL13:
 740:fltk-1.3.4-1/jpeg/jmemmgr.c ****       break;
 125              		.loc 1 740 0
 126 00bc 4D85C0   		testq	%r8, %r8
 127 00bf 7E2F     		jle	.L1
 128              	.LVL14:
 129              	.L5:
 742:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (writing)
 130              		.loc 1 742 0
 131 00c1 4C89C3   		movq	%r8, %rbx
 744:fltk-1.3.4-1/jpeg/jmemmgr.c **** 					    (void FAR *) ptr->mem_buffer[i],
 132              		.loc 1 744 0
 133 00c4 498B17   		movq	(%r15), %rdx
 134 00c7 4C89F1   		movq	%r14, %rcx
 742:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (writing)
 135              		.loc 1 742 0
 136 00ca 480FAFDD 		imulq	%rbp, %rbx
 137              	.LVL15:
 743:fltk-1.3.4-1/jpeg/jmemmgr.c ****       (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
 138              		.loc 1 743 0
 139 00ce 4585ED   		testl	%r13d, %r13d
 744:fltk-1.3.4-1/jpeg/jmemmgr.c **** 					    (void FAR *) ptr->mem_buffer[i],
 140              		.loc 1 744 0
 141 00d1 488B3424 		movq	(%rsp), %rsi
 142 00d5 488B7C24 		movq	8(%rsp), %rdi
 142      08
 143 00da 4A8B14E2 		movq	(%rdx,%r12,8), %rdx
 144 00de 4989D8   		movq	%rbx, %r8
 145              	.LVL16:
 743:fltk-1.3.4-1/jpeg/jmemmgr.c ****       (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
 146              		.loc 1 743 0
 147 00e1 7595     		jne	.L11
 148              	.LVL17:
 748:fltk-1.3.4-1/jpeg/jmemmgr.c **** 					   (void FAR *) ptr->mem_buffer[i],
 149              		.loc 1 748 0
 150 00e3 41FF5738 		call	*56(%r15)
 151              	.LVL18:
 152 00e7 EB93     		jmp	.L7
 153              	.LVL19:
 154 00e9 0F1F8000 		.p2align 4,,10
 154      000000
 155              		.p2align 3
 156              	.L1:
 752:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
 753:fltk-1.3.4-1/jpeg/jmemmgr.c **** }
 157              		.loc 1 753 0
 158 00f0 4883C418 		addq	$24, %rsp
 159              		.cfi_def_cfa_offset 56
 160 00f4 5B       		popq	%rbx
 161              		.cfi_def_cfa_offset 48
 162 00f5 5D       		popq	%rbp
 163              		.cfi_def_cfa_offset 40
 164              	.LVL20:
 165 00f6 415C     		popq	%r12
 166              		.cfi_def_cfa_offset 32
 167 00f8 415D     		popq	%r13
 168              		.cfi_def_cfa_offset 24
 169 00fa 415E     		popq	%r14
 170              		.cfi_def_cfa_offset 16
 171              	.LVL21:
 172 00fc 415F     		popq	%r15
 173              		.cfi_def_cfa_offset 8
 174 00fe C3       		ret
 175              		.cfi_endproc
 176              	.LFE70:
 178              		.section	.text.unlikely.do_barray_io
 179              	.LCOLDE0:
 180              		.section	.text.do_barray_io
 181              	.LHOTE0:
 182              		.section	.text.unlikely.alloc_small,"ax",@progbits
 183              	.LCOLDB1:
 184              		.section	.text.alloc_small,"ax",@progbits
 185              	.LHOTB1:
 186              		.p2align 4,,15
 188              	alloc_small:
 189              	.LFB62:
 260:fltk-1.3.4-1/jpeg/jmemmgr.c ****   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 190              		.loc 1 260 0
 191              		.cfi_startproc
 192              	.LVL22:
 193 0000 4157     		pushq	%r15
 194              		.cfi_def_cfa_offset 16
 195              		.cfi_offset 15, -16
 196 0002 4156     		pushq	%r14
 197              		.cfi_def_cfa_offset 24
 198              		.cfi_offset 14, -24
 199 0004 4989D7   		movq	%rdx, %r15
 200 0007 4155     		pushq	%r13
 201              		.cfi_def_cfa_offset 32
 202              		.cfi_offset 13, -32
 203 0009 4154     		pushq	%r12
 204              		.cfi_def_cfa_offset 40
 205              		.cfi_offset 12, -40
 206 000b 4989FD   		movq	%rdi, %r13
 207 000e 55       		pushq	%rbp
 208              		.cfi_def_cfa_offset 48
 209              		.cfi_offset 6, -48
 210 000f 53       		pushq	%rbx
 211              		.cfi_def_cfa_offset 56
 212              		.cfi_offset 3, -56
 213 0010 89F3     		movl	%esi, %ebx
 214 0012 4883EC18 		subq	$24, %rsp
 215              		.cfi_def_cfa_offset 80
 261:fltk-1.3.4-1/jpeg/jmemmgr.c ****   small_pool_ptr hdr_ptr, prev_hdr_ptr;
 216              		.loc 1 261 0
 217 0016 488B4708 		movq	8(%rdi), %rax
 267:fltk-1.3.4-1/jpeg/jmemmgr.c ****     out_of_memory(cinfo, 1);	/* request exceeds malloc's ability */
 218              		.loc 1 267 0
 219 001a 4881FAE8 		cmpq	$999999976, %rdx
 219      C99A3B
 261:fltk-1.3.4-1/jpeg/jmemmgr.c ****   small_pool_ptr hdr_ptr, prev_hdr_ptr;
 220              		.loc 1 261 0
 221 0021 48890424 		movq	%rax, (%rsp)
 222              	.LVL23:
 267:fltk-1.3.4-1/jpeg/jmemmgr.c ****     out_of_memory(cinfo, 1);	/* request exceeds malloc's ability */
 223              		.loc 1 267 0
 224 0025 0F872D01 		ja	.L36
 224      0000
 225              	.LVL24:
 226              	.L13:
 272:fltk-1.3.4-1/jpeg/jmemmgr.c ****     sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
 227              		.loc 1 272 0
 228 002b 4C89F8   		movq	%r15, %rax
 229 002e 83E007   		andl	$7, %eax
 230              	.LVL25:
 231 0031 7407     		je	.L14
 232 0033 4983C708 		addq	$8, %r15
 233              	.LVL26:
 273:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 234              		.loc 1 273 0
 235 0037 4929C7   		subq	%rax, %r15
 236              	.LVL27:
 237              	.L14:
 276:fltk-1.3.4-1/jpeg/jmemmgr.c ****     ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
 238              		.loc 1 276 0
 239 003a 83FB01   		cmpl	$1, %ebx
 240 003d 761B     		jbe	.L15
 277:fltk-1.3.4-1/jpeg/jmemmgr.c ****   prev_hdr_ptr = NULL;
 241              		.loc 1 277 0
 242 003f 498B4500 		movq	0(%r13), %rax
 243              	.LVL28:
 244 0043 4C89EF   		movq	%r13, %rdi
 245 0046 C740280F 		movl	$15, 40(%rax)
 245      000000
 246 004d 498B4500 		movq	0(%r13), %rax
 247 0051 89582C   		movl	%ebx, 44(%rax)
 248 0054 498B4500 		movq	0(%r13), %rax
 249 0058 FF10     		call	*(%rax)
 250              	.LVL29:
 251              	.L15:
 252 005a 488B0424 		movq	(%rsp), %rax
 253 005e 4863F3   		movslq	%ebx, %rsi
 254 0061 488D04F0 		leaq	(%rax,%rsi,8), %rax
 279:fltk-1.3.4-1/jpeg/jmemmgr.c ****   while (hdr_ptr != NULL) {
 255              		.loc 1 279 0
 256 0065 488B5868 		movq	104(%rax), %rbx
 257              	.LVL30:
 258 0069 48894424 		movq	%rax, 8(%rsp)
 258      08
 280:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (hdr_ptr->hdr.bytes_left >= sizeofobject)
 259              		.loc 1 280 0
 260 006e 4885DB   		testq	%rbx, %rbx
 261 0071 0F840E01 		je	.L16
 261      0000
 281:fltk-1.3.4-1/jpeg/jmemmgr.c ****       break;			/* found pool with enough space */
 262              		.loc 1 281 0
 263 0077 488B4B10 		movq	16(%rbx), %rcx
 264 007b 4939CF   		cmpq	%rcx, %r15
 265 007e 7718     		ja	.L19
 266 0080 E9110100 		jmp	.L37
 266      00
 267              	.LVL31:
 268              		.p2align 4,,10
 269 0085 0F1F00   		.p2align 3
 270              	.L20:
 271 0088 488B4810 		movq	16(%rax), %rcx
 272 008c 4889C3   		movq	%rax, %rbx
 273              	.LVL32:
 274 008f 4939CF   		cmpq	%rcx, %r15
 275 0092 0F869600 		jbe	.L17
 275      0000
 276              	.LVL33:
 277              	.L19:
 284:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
 278              		.loc 1 284 0
 279 0098 488B03   		movq	(%rbx), %rax
 280              	.LVL34:
 280:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (hdr_ptr->hdr.bytes_left >= sizeofobject)
 281              		.loc 1 280 0
 282 009b 4885C0   		testq	%rax, %rax
 283 009e 75E8     		jne	.L20
 294:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Don't ask for more than MAX_ALLOC_CHUNK */
 284              		.loc 1 294 0
 285 00a0 488B04F5 		movq	extra_pool_slop(,%rsi,8), %rax
 285      00000000 
 286              	.LVL35:
 290:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (prev_hdr_ptr == NULL)	/* first pool in class? */
 287              		.loc 1 290 0
 288 00a8 4D8D7718 		leaq	24(%r15), %r14
 289              	.LVL36:
 290              	.L26:
 296:fltk-1.3.4-1/jpeg/jmemmgr.c ****       slop = (size_t) (MAX_ALLOC_CHUNK-min_request);
 291              		.loc 1 296 0
 292 00ac BA00CA9A 		movl	$1000000000, %edx
 292      3B
 293 00b1 4C29F2   		subq	%r14, %rdx
 294 00b4 4839D0   		cmpq	%rdx, %rax
 295 00b7 480F46D0 		cmovbe	%rax, %rdx
 296 00bb 4989D4   		movq	%rdx, %r12
 297              	.LVL37:
 298 00be 6690     		.p2align 4,,10
 299              		.p2align 3
 300              	.L22:
 300:fltk-1.3.4-1/jpeg/jmemmgr.c ****       if (hdr_ptr != NULL)
 301              		.loc 1 300 0
 302 00c0 4B8D2C34 		leaq	(%r12,%r14), %rbp
 303 00c4 4C89EF   		movq	%r13, %rdi
 304 00c7 4889EE   		movq	%rbp, %rsi
 305 00ca E8000000 		call	jpeg_get_small
 305      00
 306              	.LVL38:
 301:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	break;
 307              		.loc 1 301 0
 308 00cf 4885C0   		testq	%rax, %rax
 309 00d2 752C     		jne	.L23
 303:fltk-1.3.4-1/jpeg/jmemmgr.c ****       if (slop < MIN_SLOP)	/* give up when it gets real small */
 310              		.loc 1 303 0
 311 00d4 49D1EC   		shrq	%r12
 312              	.LVL39:
 304:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	out_of_memory(cinfo, 2); /* jpeg_get_small failed */
 313              		.loc 1 304 0
 314 00d7 4983FC31 		cmpq	$49, %r12
 315 00db 77E3     		ja	.L22
 316              	.LVL40:
 317              	.LBB18:
 318              	.LBB19:
 225:fltk-1.3.4-1/jpeg/jmemmgr.c **** }
 319              		.loc 1 225 0
 320 00dd 498B4500 		movq	0(%r13), %rax
 321              	.LVL41:
 322 00e1 4C89EF   		movq	%r13, %rdi
 323 00e4 C7402838 		movl	$56, 40(%rax)
 323      000000
 324 00eb 498B4500 		movq	0(%r13), %rax
 325 00ef C7402C02 		movl	$2, 44(%rax)
 325      000000
 326 00f6 498B4500 		movq	0(%r13), %rax
 327 00fa FF10     		call	*(%rax)
 328              	.LVL42:
 329 00fc EBC2     		jmp	.L22
 330              	.LVL43:
 331 00fe 6690     		.p2align 4,,10
 332              		.p2align 3
 333              	.L23:
 334              	.LBE19:
 335              	.LBE18:
 307:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Success, initialize the new pool header and add to end of list */
 336              		.loc 1 307 0
 337 0100 488B3C24 		movq	(%rsp), %rdi
 311:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (prev_hdr_ptr == NULL)	/* first pool in class? */
 338              		.loc 1 311 0
 339 0104 4B8D1427 		leaq	(%r15,%r12), %rdx
 307:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Success, initialize the new pool header and add to end of list */
 340              		.loc 1 307 0
 341 0108 4801AF98 		addq	%rbp, 152(%rdi)
 341      000000
 312:fltk-1.3.4-1/jpeg/jmemmgr.c ****       mem->small_list[pool_id] = hdr_ptr;
 342              		.loc 1 312 0
 343 010f 4885DB   		testq	%rbx, %rbx
 309:fltk-1.3.4-1/jpeg/jmemmgr.c ****     hdr_ptr->hdr.bytes_used = 0;
 344              		.loc 1 309 0
 345 0112 48C70000 		movq	$0, (%rax)
 345      000000
 310:fltk-1.3.4-1/jpeg/jmemmgr.c ****     hdr_ptr->hdr.bytes_left = sizeofobject + slop;
 346              		.loc 1 310 0
 347 0119 48C74008 		movq	$0, 8(%rax)
 347      00000000 
 311:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (prev_hdr_ptr == NULL)	/* first pool in class? */
 348              		.loc 1 311 0
 349 0121 48895010 		movq	%rdx, 16(%rax)
 312:fltk-1.3.4-1/jpeg/jmemmgr.c ****       mem->small_list[pool_id] = hdr_ptr;
 350              		.loc 1 312 0
 351 0125 744F     		je	.L38
 315:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
 352              		.loc 1 315 0
 353 0127 488903   		movq	%rax, (%rbx)
 354 012a 488B4810 		movq	16(%rax), %rcx
 355              	.LVL44:
 356              	.L17:
 320:fltk-1.3.4-1/jpeg/jmemmgr.c ****   hdr_ptr->hdr.bytes_used += sizeofobject;
 357              		.loc 1 320 0
 358 012e 488B5008 		movq	8(%rax), %rdx
 359              	.LVL45:
 322:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 360              		.loc 1 322 0
 361 0132 4C29F9   		subq	%r15, %rcx
 362 0135 48894810 		movq	%rcx, 16(%rax)
 321:fltk-1.3.4-1/jpeg/jmemmgr.c ****   hdr_ptr->hdr.bytes_left -= sizeofobject;
 363              		.loc 1 321 0
 364 0139 498D3417 		leaq	(%r15,%rdx), %rsi
 365 013d 48897008 		movq	%rsi, 8(%rax)
 325:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 366              		.loc 1 325 0
 367 0141 4883C418 		addq	$24, %rsp
 368              		.cfi_remember_state
 369              		.cfi_def_cfa_offset 56
 370              	.LVL46:
 324:fltk-1.3.4-1/jpeg/jmemmgr.c **** }
 371              		.loc 1 324 0
 372 0145 488D4410 		leaq	24(%rax,%rdx), %rax
 372      18
 373              	.LVL47:
 325:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 374              		.loc 1 325 0
 375 014a 5B       		popq	%rbx
 376              		.cfi_def_cfa_offset 48
 377 014b 5D       		popq	%rbp
 378              		.cfi_def_cfa_offset 40
 379 014c 415C     		popq	%r12
 380              		.cfi_def_cfa_offset 32
 381 014e 415D     		popq	%r13
 382              		.cfi_def_cfa_offset 24
 383              	.LVL48:
 384 0150 415E     		popq	%r14
 385              		.cfi_def_cfa_offset 16
 386 0152 415F     		popq	%r15
 387              		.cfi_def_cfa_offset 8
 388              	.LVL49:
 389 0154 C3       		ret
 390              	.LVL50:
 391              		.p2align 4,,10
 392 0155 0F1F00   		.p2align 3
 393              	.L36:
 394              		.cfi_restore_state
 395              	.LBB20:
 396              	.LBB21:
 225:fltk-1.3.4-1/jpeg/jmemmgr.c **** }
 397              		.loc 1 225 0
 398 0158 488B07   		movq	(%rdi), %rax
 399              	.LVL51:
 400 015b C7402838 		movl	$56, 40(%rax)
 400      000000
 401 0162 488B07   		movq	(%rdi), %rax
 402 0165 C7402C01 		movl	$1, 44(%rax)
 402      000000
 403 016c 488B07   		movq	(%rdi), %rax
 404 016f FF10     		call	*(%rax)
 405              	.LVL52:
 406 0171 E9B5FEFF 		jmp	.L13
 406      FF
 407              	.LVL53:
 408              	.L38:
 409              	.LBE21:
 410              	.LBE20:
 313:fltk-1.3.4-1/jpeg/jmemmgr.c ****     else
 411              		.loc 1 313 0
 412 0176 488B7C24 		movq	8(%rsp), %rdi
 412      08
 413 017b 48894768 		movq	%rax, 104(%rdi)
 414 017f 488B4810 		movq	16(%rax), %rcx
 415 0183 EBA9     		jmp	.L17
 416              	.LVL54:
 417              	.L16:
 290:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (prev_hdr_ptr == NULL)	/* first pool in class? */
 418              		.loc 1 290 0
 419 0185 4D8D7718 		leaq	24(%r15), %r14
 420              	.LVL55:
 292:fltk-1.3.4-1/jpeg/jmemmgr.c ****     else
 421              		.loc 1 292 0
 422 0189 488B04F5 		movq	first_pool_slop(,%rsi,8), %rax
 422      00000000 
 423              	.LVL56:
 424 0191 E916FFFF 		jmp	.L26
 424      FF
 425              	.LVL57:
 426              	.L37:
 281:fltk-1.3.4-1/jpeg/jmemmgr.c ****       break;			/* found pool with enough space */
 427              		.loc 1 281 0
 428 0196 4889D8   		movq	%rbx, %rax
 429 0199 EB93     		jmp	.L17
 430              		.cfi_endproc
 431              	.LFE62:
 433              		.section	.text.unlikely.alloc_small
 434              	.LCOLDE1:
 435              		.section	.text.alloc_small
 436              	.LHOTE1:
 437              		.section	.text.unlikely.request_virt_barray,"ax",@progbits
 438              	.LCOLDB2:
 439              		.section	.text.request_virt_barray,"ax",@progbits
 440              	.LHOTB2:
 441              		.p2align 4,,15
 443              	request_virt_barray:
 444              	.LFB67:
 558:fltk-1.3.4-1/jpeg/jmemmgr.c ****   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 445              		.loc 1 558 0
 446              		.cfi_startproc
 447              	.LVL58:
 448 0000 4157     		pushq	%r15
 449              		.cfi_def_cfa_offset 16
 450              		.cfi_offset 15, -16
 451 0002 4156     		pushq	%r14
 452              		.cfi_def_cfa_offset 24
 453              		.cfi_offset 14, -24
 454 0004 4589C6   		movl	%r8d, %r14d
 455 0007 4155     		pushq	%r13
 456              		.cfi_def_cfa_offset 32
 457              		.cfi_offset 13, -32
 458 0009 4154     		pushq	%r12
 459              		.cfi_def_cfa_offset 40
 460              		.cfi_offset 12, -40
 461 000b 4189CD   		movl	%ecx, %r13d
 462 000e 55       		pushq	%rbp
 463              		.cfi_def_cfa_offset 48
 464              		.cfi_offset 6, -48
 465 000f 53       		pushq	%rbx
 466              		.cfi_def_cfa_offset 56
 467              		.cfi_offset 3, -56
 468 0010 89D5     		movl	%edx, %ebp
 469 0012 4889FB   		movq	%rdi, %rbx
 470 0015 4589CC   		movl	%r9d, %r12d
 471 0018 4883EC18 		subq	$24, %rsp
 472              		.cfi_def_cfa_offset 80
 563:fltk-1.3.4-1/jpeg/jmemmgr.c ****     ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
 473              		.loc 1 563 0
 474 001c 83FE01   		cmpl	$1, %esi
 559:fltk-1.3.4-1/jpeg/jmemmgr.c ****   jvirt_barray_ptr result;
 475              		.loc 1 559 0
 476 001f 4C8B7F08 		movq	8(%rdi), %r15
 477              	.LVL59:
 563:fltk-1.3.4-1/jpeg/jmemmgr.c ****     ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
 478              		.loc 1 563 0
 479 0023 741D     		je	.L40
 564:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 480              		.loc 1 564 0
 481 0025 488B07   		movq	(%rdi), %rax
 482 0028 8974240C 		movl	%esi, 12(%rsp)
 483 002c C740280F 		movl	$15, 40(%rax)
 483      000000
 484 0033 488B07   		movq	(%rdi), %rax
 485 0036 89702C   		movl	%esi, 44(%rax)
 486 0039 488B07   		movq	(%rdi), %rax
 487 003c FF10     		call	*(%rax)
 488              	.LVL60:
 489 003e 8B74240C 		movl	12(%rsp), %esi
 490              	.LVL61:
 491              	.L40:
 567:fltk-1.3.4-1/jpeg/jmemmgr.c **** 					  SIZEOF(struct jvirt_barray_control));
 492              		.loc 1 567 0
 493 0042 BA980000 		movl	$152, %edx
 493      00
 494 0047 4889DF   		movq	%rbx, %rdi
 495 004a E8000000 		call	alloc_small
 495      00
 496              	.LVL62:
 570:fltk-1.3.4-1/jpeg/jmemmgr.c ****   result->rows_in_array = numrows;
 497              		.loc 1 570 0
 498 004f 48C70000 		movq	$0, (%rax)
 498      000000
 571:fltk-1.3.4-1/jpeg/jmemmgr.c ****   result->blocksperrow = blocksperrow;
 499              		.loc 1 571 0
 500 0056 44897008 		movl	%r14d, 8(%rax)
 572:fltk-1.3.4-1/jpeg/jmemmgr.c ****   result->maxaccess = maxaccess;
 501              		.loc 1 572 0
 502 005a 4489680C 		movl	%r13d, 12(%rax)
 573:fltk-1.3.4-1/jpeg/jmemmgr.c ****   result->pre_zero = pre_zero;
 503              		.loc 1 573 0
 504 005e 44896010 		movl	%r12d, 16(%rax)
 574:fltk-1.3.4-1/jpeg/jmemmgr.c ****   result->b_s_open = FALSE;	/* no associated backing-store object */
 505              		.loc 1 574 0
 506 0062 896824   		movl	%ebp, 36(%rax)
 575:fltk-1.3.4-1/jpeg/jmemmgr.c ****   result->next = mem->virt_barray_list; /* add to list of virtual arrays */
 507              		.loc 1 575 0
 508 0065 C7402C00 		movl	$0, 44(%rax)
 508      000000
 576:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->virt_barray_list = result;
 509              		.loc 1 576 0
 510 006c 498B9790 		movq	144(%r15), %rdx
 510      000000
 511 0073 48895030 		movq	%rdx, 48(%rax)
 577:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 512              		.loc 1 577 0
 513 0077 49898790 		movq	%rax, 144(%r15)
 513      000000
 580:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 514              		.loc 1 580 0
 515 007e 4883C418 		addq	$24, %rsp
 516              		.cfi_def_cfa_offset 56
 517 0082 5B       		popq	%rbx
 518              		.cfi_def_cfa_offset 48
 519              	.LVL63:
 520 0083 5D       		popq	%rbp
 521              		.cfi_def_cfa_offset 40
 522              	.LVL64:
 523 0084 415C     		popq	%r12
 524              		.cfi_def_cfa_offset 32
 525              	.LVL65:
 526 0086 415D     		popq	%r13
 527              		.cfi_def_cfa_offset 24
 528              	.LVL66:
 529 0088 415E     		popq	%r14
 530              		.cfi_def_cfa_offset 16
 531              	.LVL67:
 532 008a 415F     		popq	%r15
 533              		.cfi_def_cfa_offset 8
 534              	.LVL68:
 535 008c C3       		ret
 536              		.cfi_endproc
 537              	.LFE67:
 539              		.section	.text.unlikely.request_virt_barray
 540              	.LCOLDE2:
 541              		.section	.text.request_virt_barray
 542              	.LHOTE2:
 543              		.section	.text.unlikely.request_virt_sarray,"ax",@progbits
 544              	.LCOLDB3:
 545              		.section	.text.request_virt_sarray,"ax",@progbits
 546              	.LHOTB3:
 547              		.p2align 4,,15
 549              	request_virt_sarray:
 550              	.LFB66:
 528:fltk-1.3.4-1/jpeg/jmemmgr.c ****   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 551              		.loc 1 528 0
 552              		.cfi_startproc
 553              	.LVL69:
 554 0000 4157     		pushq	%r15
 555              		.cfi_def_cfa_offset 16
 556              		.cfi_offset 15, -16
 557 0002 4156     		pushq	%r14
 558              		.cfi_def_cfa_offset 24
 559              		.cfi_offset 14, -24
 560 0004 4589C6   		movl	%r8d, %r14d
 561 0007 4155     		pushq	%r13
 562              		.cfi_def_cfa_offset 32
 563              		.cfi_offset 13, -32
 564 0009 4154     		pushq	%r12
 565              		.cfi_def_cfa_offset 40
 566              		.cfi_offset 12, -40
 567 000b 4189CD   		movl	%ecx, %r13d
 568 000e 55       		pushq	%rbp
 569              		.cfi_def_cfa_offset 48
 570              		.cfi_offset 6, -48
 571 000f 53       		pushq	%rbx
 572              		.cfi_def_cfa_offset 56
 573              		.cfi_offset 3, -56
 574 0010 89D5     		movl	%edx, %ebp
 575 0012 4889FB   		movq	%rdi, %rbx
 576 0015 4589CC   		movl	%r9d, %r12d
 577 0018 4883EC18 		subq	$24, %rsp
 578              		.cfi_def_cfa_offset 80
 533:fltk-1.3.4-1/jpeg/jmemmgr.c ****     ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
 579              		.loc 1 533 0
 580 001c 83FE01   		cmpl	$1, %esi
 529:fltk-1.3.4-1/jpeg/jmemmgr.c ****   jvirt_sarray_ptr result;
 581              		.loc 1 529 0
 582 001f 4C8B7F08 		movq	8(%rdi), %r15
 583              	.LVL70:
 533:fltk-1.3.4-1/jpeg/jmemmgr.c ****     ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
 584              		.loc 1 533 0
 585 0023 741D     		je	.L46
 534:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 586              		.loc 1 534 0
 587 0025 488B07   		movq	(%rdi), %rax
 588 0028 8974240C 		movl	%esi, 12(%rsp)
 589 002c C740280F 		movl	$15, 40(%rax)
 589      000000
 590 0033 488B07   		movq	(%rdi), %rax
 591 0036 89702C   		movl	%esi, 44(%rax)
 592 0039 488B07   		movq	(%rdi), %rax
 593 003c FF10     		call	*(%rax)
 594              	.LVL71:
 595 003e 8B74240C 		movl	12(%rsp), %esi
 596              	.LVL72:
 597              	.L46:
 537:fltk-1.3.4-1/jpeg/jmemmgr.c **** 					  SIZEOF(struct jvirt_sarray_control));
 598              		.loc 1 537 0
 599 0042 BA980000 		movl	$152, %edx
 599      00
 600 0047 4889DF   		movq	%rbx, %rdi
 601 004a E8000000 		call	alloc_small
 601      00
 602              	.LVL73:
 540:fltk-1.3.4-1/jpeg/jmemmgr.c ****   result->rows_in_array = numrows;
 603              		.loc 1 540 0
 604 004f 48C70000 		movq	$0, (%rax)
 604      000000
 541:fltk-1.3.4-1/jpeg/jmemmgr.c ****   result->samplesperrow = samplesperrow;
 605              		.loc 1 541 0
 606 0056 44897008 		movl	%r14d, 8(%rax)
 542:fltk-1.3.4-1/jpeg/jmemmgr.c ****   result->maxaccess = maxaccess;
 607              		.loc 1 542 0
 608 005a 4489680C 		movl	%r13d, 12(%rax)
 543:fltk-1.3.4-1/jpeg/jmemmgr.c ****   result->pre_zero = pre_zero;
 609              		.loc 1 543 0
 610 005e 44896010 		movl	%r12d, 16(%rax)
 544:fltk-1.3.4-1/jpeg/jmemmgr.c ****   result->b_s_open = FALSE;	/* no associated backing-store object */
 611              		.loc 1 544 0
 612 0062 896824   		movl	%ebp, 36(%rax)
 545:fltk-1.3.4-1/jpeg/jmemmgr.c ****   result->next = mem->virt_sarray_list; /* add to list of virtual arrays */
 613              		.loc 1 545 0
 614 0065 C7402C00 		movl	$0, 44(%rax)
 614      000000
 546:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->virt_sarray_list = result;
 615              		.loc 1 546 0
 616 006c 498B9788 		movq	136(%r15), %rdx
 616      000000
 617 0073 48895030 		movq	%rdx, 48(%rax)
 547:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 618              		.loc 1 547 0
 619 0077 49898788 		movq	%rax, 136(%r15)
 619      000000
 550:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 620              		.loc 1 550 0
 621 007e 4883C418 		addq	$24, %rsp
 622              		.cfi_def_cfa_offset 56
 623 0082 5B       		popq	%rbx
 624              		.cfi_def_cfa_offset 48
 625              	.LVL74:
 626 0083 5D       		popq	%rbp
 627              		.cfi_def_cfa_offset 40
 628              	.LVL75:
 629 0084 415C     		popq	%r12
 630              		.cfi_def_cfa_offset 32
 631              	.LVL76:
 632 0086 415D     		popq	%r13
 633              		.cfi_def_cfa_offset 24
 634              	.LVL77:
 635 0088 415E     		popq	%r14
 636              		.cfi_def_cfa_offset 16
 637              	.LVL78:
 638 008a 415F     		popq	%r15
 639              		.cfi_def_cfa_offset 8
 640              	.LVL79:
 641 008c C3       		ret
 642              		.cfi_endproc
 643              	.LFE66:
 645              		.section	.text.unlikely.request_virt_sarray
 646              	.LCOLDE3:
 647              		.section	.text.request_virt_sarray
 648              	.LHOTE3:
 649              		.section	.text.unlikely.free_pool,"ax",@progbits
 650              	.LCOLDB4:
 651              		.section	.text.free_pool,"ax",@progbits
 652              	.LHOTB4:
 653              		.p2align 4,,15
 655              	free_pool:
 656              	.LFB73:
 754:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 755:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 756:fltk-1.3.4-1/jpeg/jmemmgr.c **** METHODDEF(JSAMPARRAY)
 757:fltk-1.3.4-1/jpeg/jmemmgr.c **** access_virt_sarray (j_common_ptr cinfo, jvirt_sarray_ptr ptr,
 758:fltk-1.3.4-1/jpeg/jmemmgr.c **** 		    JDIMENSION start_row, JDIMENSION num_rows,
 759:fltk-1.3.4-1/jpeg/jmemmgr.c **** 		    boolean writable)
 760:fltk-1.3.4-1/jpeg/jmemmgr.c **** /* Access the part of a virtual sample array starting at start_row */
 761:fltk-1.3.4-1/jpeg/jmemmgr.c **** /* and extending for num_rows rows.  writable is true if  */
 762:fltk-1.3.4-1/jpeg/jmemmgr.c **** /* caller intends to modify the accessed area. */
 763:fltk-1.3.4-1/jpeg/jmemmgr.c **** {
 764:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JDIMENSION end_row = start_row + num_rows;
 765:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JDIMENSION undef_row;
 766:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 767:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* debugging check */
 768:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
 769:fltk-1.3.4-1/jpeg/jmemmgr.c ****       ptr->mem_buffer == NULL)
 770:fltk-1.3.4-1/jpeg/jmemmgr.c ****     ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 771:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 772:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Make the desired part of the virtual array accessible */
 773:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (start_row < ptr->cur_start_row ||
 774:fltk-1.3.4-1/jpeg/jmemmgr.c ****       end_row > ptr->cur_start_row+ptr->rows_in_mem) {
 775:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (! ptr->b_s_open)
 776:fltk-1.3.4-1/jpeg/jmemmgr.c ****       ERREXIT(cinfo, JERR_VIRTUAL_BUG);
 777:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Flush old buffer contents if necessary */
 778:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (ptr->dirty) {
 779:fltk-1.3.4-1/jpeg/jmemmgr.c ****       do_sarray_io(cinfo, ptr, TRUE);
 780:fltk-1.3.4-1/jpeg/jmemmgr.c ****       ptr->dirty = FALSE;
 781:fltk-1.3.4-1/jpeg/jmemmgr.c ****     }
 782:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Decide what part of virtual array to access.
 783:fltk-1.3.4-1/jpeg/jmemmgr.c ****      * Algorithm: if target address > current window, assume forward scan,
 784:fltk-1.3.4-1/jpeg/jmemmgr.c ****      * load starting at target address.  If target address < current window,
 785:fltk-1.3.4-1/jpeg/jmemmgr.c ****      * assume backward scan, load so that target area is top of window.
 786:fltk-1.3.4-1/jpeg/jmemmgr.c ****      * Note that when switching from forward write to forward read, will have
 787:fltk-1.3.4-1/jpeg/jmemmgr.c ****      * start_row = 0, so the limiting case applies and we load from 0 anyway.
 788:fltk-1.3.4-1/jpeg/jmemmgr.c ****      */
 789:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (start_row > ptr->cur_start_row) {
 790:fltk-1.3.4-1/jpeg/jmemmgr.c ****       ptr->cur_start_row = start_row;
 791:fltk-1.3.4-1/jpeg/jmemmgr.c ****     } else {
 792:fltk-1.3.4-1/jpeg/jmemmgr.c ****       /* use long arithmetic here to avoid overflow & unsigned problems */
 793:fltk-1.3.4-1/jpeg/jmemmgr.c ****       long ltemp;
 794:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 795:fltk-1.3.4-1/jpeg/jmemmgr.c ****       ltemp = (long) end_row - (long) ptr->rows_in_mem;
 796:fltk-1.3.4-1/jpeg/jmemmgr.c ****       if (ltemp < 0)
 797:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	ltemp = 0;		/* don't fall off front end of file */
 798:fltk-1.3.4-1/jpeg/jmemmgr.c ****       ptr->cur_start_row = (JDIMENSION) ltemp;
 799:fltk-1.3.4-1/jpeg/jmemmgr.c ****     }
 800:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Read in the selected part of the array.
 801:fltk-1.3.4-1/jpeg/jmemmgr.c ****      * During the initial write pass, we will do no actual read
 802:fltk-1.3.4-1/jpeg/jmemmgr.c ****      * because the selected part is all undefined.
 803:fltk-1.3.4-1/jpeg/jmemmgr.c ****      */
 804:fltk-1.3.4-1/jpeg/jmemmgr.c ****     do_sarray_io(cinfo, ptr, FALSE);
 805:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
 806:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Ensure the accessed part of the array is defined; prezero if needed.
 807:fltk-1.3.4-1/jpeg/jmemmgr.c ****    * To improve locality of access, we only prezero the part of the array
 808:fltk-1.3.4-1/jpeg/jmemmgr.c ****    * that the caller is about to access, not the entire in-memory array.
 809:fltk-1.3.4-1/jpeg/jmemmgr.c ****    */
 810:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (ptr->first_undef_row < end_row) {
 811:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (ptr->first_undef_row < start_row) {
 812:fltk-1.3.4-1/jpeg/jmemmgr.c ****       if (writable)		/* writer skipped over a section of array */
 813:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 814:fltk-1.3.4-1/jpeg/jmemmgr.c ****       undef_row = start_row;	/* but reader is allowed to read ahead */
 815:fltk-1.3.4-1/jpeg/jmemmgr.c ****     } else {
 816:fltk-1.3.4-1/jpeg/jmemmgr.c ****       undef_row = ptr->first_undef_row;
 817:fltk-1.3.4-1/jpeg/jmemmgr.c ****     }
 818:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (writable)
 819:fltk-1.3.4-1/jpeg/jmemmgr.c ****       ptr->first_undef_row = end_row;
 820:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (ptr->pre_zero) {
 821:fltk-1.3.4-1/jpeg/jmemmgr.c ****       size_t bytesperrow = (size_t) ptr->samplesperrow * SIZEOF(JSAMPLE);
 822:fltk-1.3.4-1/jpeg/jmemmgr.c ****       undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
 823:fltk-1.3.4-1/jpeg/jmemmgr.c ****       end_row -= ptr->cur_start_row;
 824:fltk-1.3.4-1/jpeg/jmemmgr.c ****       while (undef_row < end_row) {
 825:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	FMEMZERO((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
 826:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	undef_row++;
 827:fltk-1.3.4-1/jpeg/jmemmgr.c ****       }
 828:fltk-1.3.4-1/jpeg/jmemmgr.c ****     } else {
 829:fltk-1.3.4-1/jpeg/jmemmgr.c ****       if (! writable)		/* reader looking at undefined data */
 830:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 831:fltk-1.3.4-1/jpeg/jmemmgr.c ****     }
 832:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
 833:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Flag the buffer dirty if caller will write in it */
 834:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (writable)
 835:fltk-1.3.4-1/jpeg/jmemmgr.c ****     ptr->dirty = TRUE;
 836:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Return address of proper part of the buffer */
 837:fltk-1.3.4-1/jpeg/jmemmgr.c ****   return ptr->mem_buffer + (start_row - ptr->cur_start_row);
 838:fltk-1.3.4-1/jpeg/jmemmgr.c **** }
 839:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 840:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 841:fltk-1.3.4-1/jpeg/jmemmgr.c **** METHODDEF(JBLOCKARRAY)
 842:fltk-1.3.4-1/jpeg/jmemmgr.c **** access_virt_barray (j_common_ptr cinfo, jvirt_barray_ptr ptr,
 843:fltk-1.3.4-1/jpeg/jmemmgr.c **** 		    JDIMENSION start_row, JDIMENSION num_rows,
 844:fltk-1.3.4-1/jpeg/jmemmgr.c **** 		    boolean writable)
 845:fltk-1.3.4-1/jpeg/jmemmgr.c **** /* Access the part of a virtual block array starting at start_row */
 846:fltk-1.3.4-1/jpeg/jmemmgr.c **** /* and extending for num_rows rows.  writable is true if  */
 847:fltk-1.3.4-1/jpeg/jmemmgr.c **** /* caller intends to modify the accessed area. */
 848:fltk-1.3.4-1/jpeg/jmemmgr.c **** {
 849:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JDIMENSION end_row = start_row + num_rows;
 850:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JDIMENSION undef_row;
 851:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 852:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* debugging check */
 853:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
 854:fltk-1.3.4-1/jpeg/jmemmgr.c ****       ptr->mem_buffer == NULL)
 855:fltk-1.3.4-1/jpeg/jmemmgr.c ****     ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 856:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 857:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Make the desired part of the virtual array accessible */
 858:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (start_row < ptr->cur_start_row ||
 859:fltk-1.3.4-1/jpeg/jmemmgr.c ****       end_row > ptr->cur_start_row+ptr->rows_in_mem) {
 860:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (! ptr->b_s_open)
 861:fltk-1.3.4-1/jpeg/jmemmgr.c ****       ERREXIT(cinfo, JERR_VIRTUAL_BUG);
 862:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Flush old buffer contents if necessary */
 863:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (ptr->dirty) {
 864:fltk-1.3.4-1/jpeg/jmemmgr.c ****       do_barray_io(cinfo, ptr, TRUE);
 865:fltk-1.3.4-1/jpeg/jmemmgr.c ****       ptr->dirty = FALSE;
 866:fltk-1.3.4-1/jpeg/jmemmgr.c ****     }
 867:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Decide what part of virtual array to access.
 868:fltk-1.3.4-1/jpeg/jmemmgr.c ****      * Algorithm: if target address > current window, assume forward scan,
 869:fltk-1.3.4-1/jpeg/jmemmgr.c ****      * load starting at target address.  If target address < current window,
 870:fltk-1.3.4-1/jpeg/jmemmgr.c ****      * assume backward scan, load so that target area is top of window.
 871:fltk-1.3.4-1/jpeg/jmemmgr.c ****      * Note that when switching from forward write to forward read, will have
 872:fltk-1.3.4-1/jpeg/jmemmgr.c ****      * start_row = 0, so the limiting case applies and we load from 0 anyway.
 873:fltk-1.3.4-1/jpeg/jmemmgr.c ****      */
 874:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (start_row > ptr->cur_start_row) {
 875:fltk-1.3.4-1/jpeg/jmemmgr.c ****       ptr->cur_start_row = start_row;
 876:fltk-1.3.4-1/jpeg/jmemmgr.c ****     } else {
 877:fltk-1.3.4-1/jpeg/jmemmgr.c ****       /* use long arithmetic here to avoid overflow & unsigned problems */
 878:fltk-1.3.4-1/jpeg/jmemmgr.c ****       long ltemp;
 879:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 880:fltk-1.3.4-1/jpeg/jmemmgr.c ****       ltemp = (long) end_row - (long) ptr->rows_in_mem;
 881:fltk-1.3.4-1/jpeg/jmemmgr.c ****       if (ltemp < 0)
 882:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	ltemp = 0;		/* don't fall off front end of file */
 883:fltk-1.3.4-1/jpeg/jmemmgr.c ****       ptr->cur_start_row = (JDIMENSION) ltemp;
 884:fltk-1.3.4-1/jpeg/jmemmgr.c ****     }
 885:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Read in the selected part of the array.
 886:fltk-1.3.4-1/jpeg/jmemmgr.c ****      * During the initial write pass, we will do no actual read
 887:fltk-1.3.4-1/jpeg/jmemmgr.c ****      * because the selected part is all undefined.
 888:fltk-1.3.4-1/jpeg/jmemmgr.c ****      */
 889:fltk-1.3.4-1/jpeg/jmemmgr.c ****     do_barray_io(cinfo, ptr, FALSE);
 890:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
 891:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Ensure the accessed part of the array is defined; prezero if needed.
 892:fltk-1.3.4-1/jpeg/jmemmgr.c ****    * To improve locality of access, we only prezero the part of the array
 893:fltk-1.3.4-1/jpeg/jmemmgr.c ****    * that the caller is about to access, not the entire in-memory array.
 894:fltk-1.3.4-1/jpeg/jmemmgr.c ****    */
 895:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (ptr->first_undef_row < end_row) {
 896:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (ptr->first_undef_row < start_row) {
 897:fltk-1.3.4-1/jpeg/jmemmgr.c ****       if (writable)		/* writer skipped over a section of array */
 898:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 899:fltk-1.3.4-1/jpeg/jmemmgr.c ****       undef_row = start_row;	/* but reader is allowed to read ahead */
 900:fltk-1.3.4-1/jpeg/jmemmgr.c ****     } else {
 901:fltk-1.3.4-1/jpeg/jmemmgr.c ****       undef_row = ptr->first_undef_row;
 902:fltk-1.3.4-1/jpeg/jmemmgr.c ****     }
 903:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (writable)
 904:fltk-1.3.4-1/jpeg/jmemmgr.c ****       ptr->first_undef_row = end_row;
 905:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (ptr->pre_zero) {
 906:fltk-1.3.4-1/jpeg/jmemmgr.c ****       size_t bytesperrow = (size_t) ptr->blocksperrow * SIZEOF(JBLOCK);
 907:fltk-1.3.4-1/jpeg/jmemmgr.c ****       undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
 908:fltk-1.3.4-1/jpeg/jmemmgr.c ****       end_row -= ptr->cur_start_row;
 909:fltk-1.3.4-1/jpeg/jmemmgr.c ****       while (undef_row < end_row) {
 910:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	FMEMZERO((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
 911:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	undef_row++;
 912:fltk-1.3.4-1/jpeg/jmemmgr.c ****       }
 913:fltk-1.3.4-1/jpeg/jmemmgr.c ****     } else {
 914:fltk-1.3.4-1/jpeg/jmemmgr.c ****       if (! writable)		/* reader looking at undefined data */
 915:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 916:fltk-1.3.4-1/jpeg/jmemmgr.c ****     }
 917:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
 918:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Flag the buffer dirty if caller will write in it */
 919:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (writable)
 920:fltk-1.3.4-1/jpeg/jmemmgr.c ****     ptr->dirty = TRUE;
 921:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Return address of proper part of the buffer */
 922:fltk-1.3.4-1/jpeg/jmemmgr.c ****   return ptr->mem_buffer + (start_row - ptr->cur_start_row);
 923:fltk-1.3.4-1/jpeg/jmemmgr.c **** }
 924:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 925:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 926:fltk-1.3.4-1/jpeg/jmemmgr.c **** /*
 927:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * Release all objects belonging to a specified pool.
 928:fltk-1.3.4-1/jpeg/jmemmgr.c ****  */
 929:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 930:fltk-1.3.4-1/jpeg/jmemmgr.c **** METHODDEF(void)
 931:fltk-1.3.4-1/jpeg/jmemmgr.c **** free_pool (j_common_ptr cinfo, int pool_id)
 932:fltk-1.3.4-1/jpeg/jmemmgr.c **** {
 657              		.loc 1 932 0
 658              		.cfi_startproc
 659              	.LVL80:
 660 0000 4156     		pushq	%r14
 661              		.cfi_def_cfa_offset 16
 662              		.cfi_offset 14, -16
 663 0002 4155     		pushq	%r13
 664              		.cfi_def_cfa_offset 24
 665              		.cfi_offset 13, -24
 666 0004 4C63EE   		movslq	%esi, %r13
 933:fltk-1.3.4-1/jpeg/jmemmgr.c ****   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 934:fltk-1.3.4-1/jpeg/jmemmgr.c ****   small_pool_ptr shdr_ptr;
 935:fltk-1.3.4-1/jpeg/jmemmgr.c ****   large_pool_ptr lhdr_ptr;
 936:fltk-1.3.4-1/jpeg/jmemmgr.c ****   size_t space_freed;
 937:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 938:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
 667              		.loc 1 938 0
 668 0007 4183FD01 		cmpl	$1, %r13d
 932:fltk-1.3.4-1/jpeg/jmemmgr.c ****   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 669              		.loc 1 932 0
 670 000b 4154     		pushq	%r12
 671              		.cfi_def_cfa_offset 32
 672              		.cfi_offset 12, -32
 673 000d 4989FC   		movq	%rdi, %r12
 674 0010 55       		pushq	%rbp
 675              		.cfi_def_cfa_offset 40
 676              		.cfi_offset 6, -40
 677 0011 53       		pushq	%rbx
 678              		.cfi_def_cfa_offset 48
 679              		.cfi_offset 3, -48
 933:fltk-1.3.4-1/jpeg/jmemmgr.c ****   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 680              		.loc 1 933 0
 681 0012 488B6F08 		movq	8(%rdi), %rbp
 682              	.LVL81:
 683              		.loc 1 938 0
 684 0016 0F86AC00 		jbe	.L52
 684      0000
 939:fltk-1.3.4-1/jpeg/jmemmgr.c ****     ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
 685              		.loc 1 939 0
 686 001c 488B07   		movq	(%rdi), %rax
 687 001f C740280F 		movl	$15, 40(%rax)
 687      000000
 688 0026 488B07   		movq	(%rdi), %rax
 689 0029 4489682C 		movl	%r13d, 44(%rax)
 690 002d 488B07   		movq	(%rdi), %rax
 691 0030 FF10     		call	*(%rax)
 692              	.LVL82:
 693              	.L53:
 694 0032 4E8D74ED 		leaq	0(%rbp,%r13,8), %r14
 694      00
 940:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 941:fltk-1.3.4-1/jpeg/jmemmgr.c **** #ifdef MEM_STATS
 942:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (cinfo->err->trace_level > 1)
 943:fltk-1.3.4-1/jpeg/jmemmgr.c ****     print_mem_stats(cinfo, pool_id); /* print pool's memory usage statistics */
 944:fltk-1.3.4-1/jpeg/jmemmgr.c **** #endif
 945:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 946:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* If freeing IMAGE pool, close any virtual arrays first */
 947:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (pool_id == JPOOL_IMAGE) {
 948:fltk-1.3.4-1/jpeg/jmemmgr.c ****     jvirt_sarray_ptr sptr;
 949:fltk-1.3.4-1/jpeg/jmemmgr.c ****     jvirt_barray_ptr bptr;
 950:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 951:fltk-1.3.4-1/jpeg/jmemmgr.c ****     for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
 952:fltk-1.3.4-1/jpeg/jmemmgr.c ****       if (sptr->b_s_open) {	/* there may be no backing store */
 953:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	sptr->b_s_open = FALSE;	/* prevent recursive close if error */
 954:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	(*sptr->b_s_info.close_backing_store) (cinfo, & sptr->b_s_info);
 955:fltk-1.3.4-1/jpeg/jmemmgr.c ****       }
 956:fltk-1.3.4-1/jpeg/jmemmgr.c ****     }
 957:fltk-1.3.4-1/jpeg/jmemmgr.c ****     mem->virt_sarray_list = NULL;
 958:fltk-1.3.4-1/jpeg/jmemmgr.c ****     for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
 959:fltk-1.3.4-1/jpeg/jmemmgr.c ****       if (bptr->b_s_open) {	/* there may be no backing store */
 960:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	bptr->b_s_open = FALSE;	/* prevent recursive close if error */
 961:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	(*bptr->b_s_info.close_backing_store) (cinfo, & bptr->b_s_info);
 962:fltk-1.3.4-1/jpeg/jmemmgr.c ****       }
 963:fltk-1.3.4-1/jpeg/jmemmgr.c ****     }
 964:fltk-1.3.4-1/jpeg/jmemmgr.c ****     mem->virt_barray_list = NULL;
 965:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
 966:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 967:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Release large objects */
 968:fltk-1.3.4-1/jpeg/jmemmgr.c ****   lhdr_ptr = mem->large_list[pool_id];
 695              		.loc 1 968 0
 696 0037 498B7678 		movq	120(%r14), %rsi
 697              	.LVL83:
 969:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->large_list[pool_id] = NULL;
 698              		.loc 1 969 0
 699 003b 49C74678 		movq	$0, 120(%r14)
 699      00000000 
 970:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 971:fltk-1.3.4-1/jpeg/jmemmgr.c ****   while (lhdr_ptr != NULL) {
 700              		.loc 1 971 0
 701 0043 4885F6   		testq	%rsi, %rsi
 702 0046 7431     		je	.L66
 703              	.LVL84:
 704 0048 0F1F8400 		.p2align 4,,10
 704      00000000 
 705              		.p2align 3
 706              	.L69:
 707              	.LBB22:
 972:fltk-1.3.4-1/jpeg/jmemmgr.c ****     large_pool_ptr next_lhdr_ptr = lhdr_ptr->hdr.next;
 973:fltk-1.3.4-1/jpeg/jmemmgr.c ****     space_freed = lhdr_ptr->hdr.bytes_used +
 708              		.loc 1 973 0
 709 0050 488B5E10 		movq	16(%rsi), %rbx
 710 0054 48035E08 		addq	8(%rsi), %rbx
 974:fltk-1.3.4-1/jpeg/jmemmgr.c **** 		  lhdr_ptr->hdr.bytes_left +
 975:fltk-1.3.4-1/jpeg/jmemmgr.c **** 		  SIZEOF(large_pool_hdr);
 976:fltk-1.3.4-1/jpeg/jmemmgr.c ****     jpeg_free_large(cinfo, (void FAR *) lhdr_ptr, space_freed);
 711              		.loc 1 976 0
 712 0058 4C89E7   		movq	%r12, %rdi
 972:fltk-1.3.4-1/jpeg/jmemmgr.c ****     large_pool_ptr next_lhdr_ptr = lhdr_ptr->hdr.next;
 713              		.loc 1 972 0
 714 005b 4C8B2E   		movq	(%rsi), %r13
 715              	.LVL85:
 973:fltk-1.3.4-1/jpeg/jmemmgr.c **** 		  lhdr_ptr->hdr.bytes_left +
 716              		.loc 1 973 0
 717 005e 4883C318 		addq	$24, %rbx
 718              	.LVL86:
 719              		.loc 1 976 0
 720 0062 4889DA   		movq	%rbx, %rdx
 721 0065 E8000000 		call	jpeg_free_large
 721      00
 722              	.LVL87:
 977:fltk-1.3.4-1/jpeg/jmemmgr.c ****     mem->total_space_allocated -= space_freed;
 723              		.loc 1 977 0
 724 006a 48299D98 		subq	%rbx, 152(%rbp)
 724      000000
 725              	.LVL88:
 726              	.LBE22:
 971:fltk-1.3.4-1/jpeg/jmemmgr.c ****     large_pool_ptr next_lhdr_ptr = lhdr_ptr->hdr.next;
 727              		.loc 1 971 0
 728 0071 4D85ED   		testq	%r13, %r13
 729 0074 4C89EE   		movq	%r13, %rsi
 730 0077 75D7     		jne	.L69
 731              	.LVL89:
 732              	.L66:
 978:fltk-1.3.4-1/jpeg/jmemmgr.c ****     lhdr_ptr = next_lhdr_ptr;
 979:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
 980:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 981:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Release small objects */
 982:fltk-1.3.4-1/jpeg/jmemmgr.c ****   shdr_ptr = mem->small_list[pool_id];
 733              		.loc 1 982 0
 734 0079 498B7668 		movq	104(%r14), %rsi
 735              	.LVL90:
 983:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->small_list[pool_id] = NULL;
 736              		.loc 1 983 0
 737 007d 49C74668 		movq	$0, 104(%r14)
 737      00000000 
 984:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 985:fltk-1.3.4-1/jpeg/jmemmgr.c ****   while (shdr_ptr != NULL) {
 738              		.loc 1 985 0
 739 0085 4885F6   		testq	%rsi, %rsi
 740 0088 742F     		je	.L51
 741 008a 660F1F44 		.p2align 4,,10
 741      0000
 742              		.p2align 3
 743              	.L68:
 744              	.LBB23:
 986:fltk-1.3.4-1/jpeg/jmemmgr.c ****     small_pool_ptr next_shdr_ptr = shdr_ptr->hdr.next;
 987:fltk-1.3.4-1/jpeg/jmemmgr.c ****     space_freed = shdr_ptr->hdr.bytes_used +
 745              		.loc 1 987 0
 746 0090 488B5E10 		movq	16(%rsi), %rbx
 747 0094 48035E08 		addq	8(%rsi), %rbx
 988:fltk-1.3.4-1/jpeg/jmemmgr.c **** 		  shdr_ptr->hdr.bytes_left +
 989:fltk-1.3.4-1/jpeg/jmemmgr.c **** 		  SIZEOF(small_pool_hdr);
 990:fltk-1.3.4-1/jpeg/jmemmgr.c ****     jpeg_free_small(cinfo, (void *) shdr_ptr, space_freed);
 748              		.loc 1 990 0
 749 0098 4C89E7   		movq	%r12, %rdi
 986:fltk-1.3.4-1/jpeg/jmemmgr.c ****     small_pool_ptr next_shdr_ptr = shdr_ptr->hdr.next;
 750              		.loc 1 986 0
 751 009b 4C8B2E   		movq	(%rsi), %r13
 752              	.LVL91:
 987:fltk-1.3.4-1/jpeg/jmemmgr.c **** 		  shdr_ptr->hdr.bytes_left +
 753              		.loc 1 987 0
 754 009e 4883C318 		addq	$24, %rbx
 755              	.LVL92:
 756              		.loc 1 990 0
 757 00a2 4889DA   		movq	%rbx, %rdx
 758 00a5 E8000000 		call	jpeg_free_small
 758      00
 759              	.LVL93:
 991:fltk-1.3.4-1/jpeg/jmemmgr.c ****     mem->total_space_allocated -= space_freed;
 760              		.loc 1 991 0
 761 00aa 48299D98 		subq	%rbx, 152(%rbp)
 761      000000
 762              	.LVL94:
 763              	.LBE23:
 985:fltk-1.3.4-1/jpeg/jmemmgr.c ****     small_pool_ptr next_shdr_ptr = shdr_ptr->hdr.next;
 764              		.loc 1 985 0
 765 00b1 4D85ED   		testq	%r13, %r13
 766 00b4 4C89EE   		movq	%r13, %rsi
 767 00b7 75D7     		jne	.L68
 768              	.LVL95:
 769              	.L51:
 992:fltk-1.3.4-1/jpeg/jmemmgr.c ****     shdr_ptr = next_shdr_ptr;
 993:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
 994:fltk-1.3.4-1/jpeg/jmemmgr.c **** }
 770              		.loc 1 994 0
 771 00b9 5B       		popq	%rbx
 772              		.cfi_remember_state
 773              		.cfi_def_cfa_offset 40
 774 00ba 5D       		popq	%rbp
 775              		.cfi_def_cfa_offset 32
 776              	.LVL96:
 777 00bb 415C     		popq	%r12
 778              		.cfi_def_cfa_offset 24
 779              	.LVL97:
 780 00bd 415D     		popq	%r13
 781              		.cfi_def_cfa_offset 16
 782 00bf 415E     		popq	%r14
 783              		.cfi_def_cfa_offset 8
 784 00c1 C3       		ret
 785              	.LVL98:
 786              		.p2align 4,,10
 787 00c2 660F1F44 		.p2align 3
 787      0000
 788              	.L52:
 789              		.cfi_restore_state
 947:fltk-1.3.4-1/jpeg/jmemmgr.c ****     jvirt_sarray_ptr sptr;
 790              		.loc 1 947 0
 791 00c8 0F8564FF 		jne	.L53
 791      FFFF
 792              	.LBB24:
 951:fltk-1.3.4-1/jpeg/jmemmgr.c ****       if (sptr->b_s_open) {	/* there may be no backing store */
 793              		.loc 1 951 0
 794 00ce 488B9D88 		movq	136(%rbp), %rbx
 794      000000
 795              	.LVL99:
 796 00d5 4885DB   		testq	%rbx, %rbx
 797 00d8 750F     		jne	.L71
 798 00da EB2E     		jmp	.L59
 799              	.LVL100:
 800 00dc 0F1F4000 		.p2align 4,,10
 801              		.p2align 3
 802              	.L57:
 951:fltk-1.3.4-1/jpeg/jmemmgr.c ****       if (sptr->b_s_open) {	/* there may be no backing store */
 803              		.loc 1 951 0 is_stmt 0 discriminator 2
 804 00e0 488B5B30 		movq	48(%rbx), %rbx
 805              	.LVL101:
 806 00e4 4885DB   		testq	%rbx, %rbx
 807 00e7 7421     		je	.L59
 808              	.L71:
 952:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	sptr->b_s_open = FALSE;	/* prevent recursive close if error */
 809              		.loc 1 952 0 is_stmt 1
 810 00e9 8B532C   		movl	44(%rbx), %edx
 811 00ec 85D2     		testl	%edx, %edx
 812 00ee 74F0     		je	.L57
 953:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	(*sptr->b_s_info.close_backing_store) (cinfo, & sptr->b_s_info);
 813              		.loc 1 953 0
 814 00f0 C7432C00 		movl	$0, 44(%rbx)
 814      000000
 954:fltk-1.3.4-1/jpeg/jmemmgr.c ****       }
 815              		.loc 1 954 0
 816 00f7 488D7338 		leaq	56(%rbx), %rsi
 817 00fb 4C89E7   		movq	%r12, %rdi
 818 00fe FF5348   		call	*72(%rbx)
 819              	.LVL102:
 951:fltk-1.3.4-1/jpeg/jmemmgr.c ****       if (sptr->b_s_open) {	/* there may be no backing store */
 820              		.loc 1 951 0
 821 0101 488B5B30 		movq	48(%rbx), %rbx
 822              	.LVL103:
 823 0105 4885DB   		testq	%rbx, %rbx
 824 0108 75DF     		jne	.L71
 825              	.L59:
 958:fltk-1.3.4-1/jpeg/jmemmgr.c ****       if (bptr->b_s_open) {	/* there may be no backing store */
 826              		.loc 1 958 0
 827 010a 488B9D90 		movq	144(%rbp), %rbx
 827      000000
 828              	.LVL104:
 957:fltk-1.3.4-1/jpeg/jmemmgr.c ****     for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
 829              		.loc 1 957 0
 830 0111 48C78588 		movq	$0, 136(%rbp)
 830      00000000 
 830      000000
 958:fltk-1.3.4-1/jpeg/jmemmgr.c ****       if (bptr->b_s_open) {	/* there may be no backing store */
 831              		.loc 1 958 0
 832 011c 4885DB   		testq	%rbx, %rbx
 833 011f 7510     		jne	.L70
 834 0121 EB2F     		jmp	.L56
 835              		.p2align 4,,10
 836 0123 0F1F4400 		.p2align 3
 836      00
 837              	.L60:
 958:fltk-1.3.4-1/jpeg/jmemmgr.c ****       if (bptr->b_s_open) {	/* there may be no backing store */
 838              		.loc 1 958 0 is_stmt 0 discriminator 2
 839 0128 488B5B30 		movq	48(%rbx), %rbx
 840              	.LVL105:
 841 012c 4885DB   		testq	%rbx, %rbx
 842 012f 7421     		je	.L56
 843              	.L70:
 959:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	bptr->b_s_open = FALSE;	/* prevent recursive close if error */
 844              		.loc 1 959 0 is_stmt 1
 845 0131 8B432C   		movl	44(%rbx), %eax
 846 0134 85C0     		testl	%eax, %eax
 847 0136 74F0     		je	.L60
 960:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	(*bptr->b_s_info.close_backing_store) (cinfo, & bptr->b_s_info);
 848              		.loc 1 960 0
 849 0138 C7432C00 		movl	$0, 44(%rbx)
 849      000000
 961:fltk-1.3.4-1/jpeg/jmemmgr.c ****       }
 850              		.loc 1 961 0
 851 013f 488D7338 		leaq	56(%rbx), %rsi
 852 0143 4C89E7   		movq	%r12, %rdi
 853 0146 FF5348   		call	*72(%rbx)
 854              	.LVL106:
 958:fltk-1.3.4-1/jpeg/jmemmgr.c ****       if (bptr->b_s_open) {	/* there may be no backing store */
 855              		.loc 1 958 0
 856 0149 488B5B30 		movq	48(%rbx), %rbx
 857              	.LVL107:
 858 014d 4885DB   		testq	%rbx, %rbx
 859 0150 75DF     		jne	.L70
 860              	.L56:
 964:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
 861              		.loc 1 964 0
 862 0152 48C78590 		movq	$0, 144(%rbp)
 862      00000000 
 862      000000
 863 015d E9D0FEFF 		jmp	.L53
 863      FF
 864              	.LBE24:
 865              		.cfi_endproc
 866              	.LFE73:
 868              		.section	.text.unlikely.free_pool
 869              	.LCOLDE4:
 870              		.section	.text.free_pool
 871              	.LHOTE4:
 872              		.section	.text.unlikely.self_destruct,"ax",@progbits
 873              	.LCOLDB5:
 874              		.section	.text.self_destruct,"ax",@progbits
 875              	.LHOTB5:
 876              		.p2align 4,,15
 878              	self_destruct:
 879              	.LFB74:
 995:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 996:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 997:fltk-1.3.4-1/jpeg/jmemmgr.c **** /*
 998:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * Close up shop entirely.
 999:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * Note that this cannot be called unless cinfo->mem is non-NULL.
1000:fltk-1.3.4-1/jpeg/jmemmgr.c ****  */
1001:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
1002:fltk-1.3.4-1/jpeg/jmemmgr.c **** METHODDEF(void)
1003:fltk-1.3.4-1/jpeg/jmemmgr.c **** self_destruct (j_common_ptr cinfo)
1004:fltk-1.3.4-1/jpeg/jmemmgr.c **** {
 880              		.loc 1 1004 0
 881              		.cfi_startproc
 882              	.LVL108:
 883 0000 53       		pushq	%rbx
 884              		.cfi_def_cfa_offset 16
 885              		.cfi_offset 3, -16
1005:fltk-1.3.4-1/jpeg/jmemmgr.c ****   int pool;
1006:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
1007:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Close all backing store, release all memory.
1008:fltk-1.3.4-1/jpeg/jmemmgr.c ****    * Releasing pools in reverse order might help avoid fragmentation
1009:fltk-1.3.4-1/jpeg/jmemmgr.c ****    * with some (brain-damaged) malloc libraries.
1010:fltk-1.3.4-1/jpeg/jmemmgr.c ****    */
1011:fltk-1.3.4-1/jpeg/jmemmgr.c ****   for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
1012:fltk-1.3.4-1/jpeg/jmemmgr.c ****     free_pool(cinfo, pool);
 886              		.loc 1 1012 0
 887 0001 BE010000 		movl	$1, %esi
 887      00
1004:fltk-1.3.4-1/jpeg/jmemmgr.c ****   int pool;
 888              		.loc 1 1004 0
 889 0006 4889FB   		movq	%rdi, %rbx
 890              		.loc 1 1012 0
 891 0009 E8000000 		call	free_pool
 891      00
 892              	.LVL109:
 893 000e 4889DF   		movq	%rbx, %rdi
 894 0011 31F6     		xorl	%esi, %esi
 895 0013 E8000000 		call	free_pool
 895      00
 896              	.LVL110:
1013:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
1014:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
1015:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Release the memory manager control block too. */
1016:fltk-1.3.4-1/jpeg/jmemmgr.c ****   jpeg_free_small(cinfo, (void *) cinfo->mem, SIZEOF(my_memory_mgr));
 897              		.loc 1 1016 0
 898 0018 488B7308 		movq	8(%rbx), %rsi
 899 001c 4889DF   		movq	%rbx, %rdi
 900 001f BAA80000 		movl	$168, %edx
 900      00
 901 0024 E8000000 		call	jpeg_free_small
 901      00
 902              	.LVL111:
1017:fltk-1.3.4-1/jpeg/jmemmgr.c ****   cinfo->mem = NULL;		/* ensures I will be called only once */
 903              		.loc 1 1017 0
 904 0029 48C74308 		movq	$0, 8(%rbx)
 904      00000000 
1018:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
1019:fltk-1.3.4-1/jpeg/jmemmgr.c ****   jpeg_mem_term(cinfo);		/* system-dependent cleanup */
 905              		.loc 1 1019 0
 906 0031 4889DF   		movq	%rbx, %rdi
1020:fltk-1.3.4-1/jpeg/jmemmgr.c **** }
 907              		.loc 1 1020 0
 908 0034 5B       		popq	%rbx
 909              		.cfi_def_cfa_offset 8
 910              	.LVL112:
1019:fltk-1.3.4-1/jpeg/jmemmgr.c **** }
 911              		.loc 1 1019 0
 912 0035 E9000000 		jmp	jpeg_mem_term
 912      00
 913              	.LVL113:
 914              		.cfi_endproc
 915              	.LFE74:
 917              		.section	.text.unlikely.self_destruct
 918              	.LCOLDE5:
 919              		.section	.text.self_destruct
 920              	.LHOTE5:
 921              		.section	.text.unlikely.access_virt_barray,"ax",@progbits
 922              	.LCOLDB6:
 923              		.section	.text.access_virt_barray,"ax",@progbits
 924              	.LHOTB6:
 925              		.p2align 4,,15
 927              	access_virt_barray:
 928              	.LFB72:
 848:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JDIMENSION end_row = start_row + num_rows;
 929              		.loc 1 848 0
 930              		.cfi_startproc
 931              	.LVL114:
 932 0000 4157     		pushq	%r15
 933              		.cfi_def_cfa_offset 16
 934              		.cfi_offset 15, -16
 935 0002 4156     		pushq	%r14
 936              		.cfi_def_cfa_offset 24
 937              		.cfi_offset 14, -24
 938 0004 4589C7   		movl	%r8d, %r15d
 939 0007 4155     		pushq	%r13
 940              		.cfi_def_cfa_offset 32
 941              		.cfi_offset 13, -32
 942 0009 4154     		pushq	%r12
 943              		.cfi_def_cfa_offset 40
 944              		.cfi_offset 12, -40
 849:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JDIMENSION undef_row;
 945              		.loc 1 849 0
 946 000b 448D2C0A 		leal	(%rdx,%rcx), %r13d
 947              	.LVL115:
 848:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JDIMENSION end_row = start_row + num_rows;
 948              		.loc 1 848 0
 949 000f 55       		pushq	%rbp
 950              		.cfi_def_cfa_offset 48
 951              		.cfi_offset 6, -48
 952 0010 53       		pushq	%rbx
 953              		.cfi_def_cfa_offset 56
 954              		.cfi_offset 3, -56
 955 0011 4989FE   		movq	%rdi, %r14
 956 0014 4889F3   		movq	%rsi, %rbx
 957 0017 4189D4   		movl	%edx, %r12d
 958 001a 4883EC08 		subq	$8, %rsp
 959              		.cfi_def_cfa_offset 64
 853:fltk-1.3.4-1/jpeg/jmemmgr.c ****       ptr->mem_buffer == NULL)
 960              		.loc 1 853 0
 961 001e 443B6E08 		cmpl	8(%rsi), %r13d
 962 0022 7709     		ja	.L80
 853:fltk-1.3.4-1/jpeg/jmemmgr.c ****       ptr->mem_buffer == NULL)
 963              		.loc 1 853 0 is_stmt 0 discriminator 1
 964 0024 3B4E10   		cmpl	16(%rsi), %ecx
 965 0027 0F86FB00 		jbe	.L110
 965      0000
 966              	.L80:
 855:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 967              		.loc 1 855 0 is_stmt 1
 968 002d 498B06   		movq	(%r14), %rax
 969 0030 4C89F7   		movq	%r14, %rdi
 970              	.LVL116:
 971 0033 C7402817 		movl	$23, 40(%rax)
 971      000000
 972 003a 498B06   		movq	(%r14), %rax
 973 003d FF10     		call	*(%rax)
 974              	.LVL117:
 975              	.L81:
 858:fltk-1.3.4-1/jpeg/jmemmgr.c ****       end_row > ptr->cur_start_row+ptr->rows_in_mem) {
 976              		.loc 1 858 0
 977 003f 8B431C   		movl	28(%rbx), %eax
 978 0042 4139C4   		cmpl	%eax, %r12d
 979 0045 7208     		jb	.L82
 858:fltk-1.3.4-1/jpeg/jmemmgr.c ****       end_row > ptr->cur_start_row+ptr->rows_in_mem) {
 980              		.loc 1 858 0 is_stmt 0 discriminator 1
 981 0047 034314   		addl	20(%rbx), %eax
 982 004a 4139C5   		cmpl	%eax, %r13d
 983 004d 7642     		jbe	.L83
 984              	.L82:
 860:fltk-1.3.4-1/jpeg/jmemmgr.c ****       ERREXIT(cinfo, JERR_VIRTUAL_BUG);
 985              		.loc 1 860 0 is_stmt 1
 986 004f 8B732C   		movl	44(%rbx), %esi
 987 0052 85F6     		testl	%esi, %esi
 988 0054 0F842601 		je	.L111
 988      0000
 989              	.L84:
 863:fltk-1.3.4-1/jpeg/jmemmgr.c ****       do_barray_io(cinfo, ptr, TRUE);
 990              		.loc 1 863 0
 991 005a 8B4B28   		movl	40(%rbx), %ecx
 992 005d 85C9     		testl	%ecx, %ecx
 993 005f 0F85FB00 		jne	.L112
 993      0000
 994              	.L85:
 874:fltk-1.3.4-1/jpeg/jmemmgr.c ****       ptr->cur_start_row = start_row;
 995              		.loc 1 874 0
 996 0065 443B631C 		cmpl	28(%rbx), %r12d
 997 0069 0F87A900 		ja	.L113
 997      0000
 998              	.LBB25:
 880:fltk-1.3.4-1/jpeg/jmemmgr.c ****       if (ltemp < 0)
 999              		.loc 1 880 0
 1000 006f 8B5314   		movl	20(%rbx), %edx
 1001 0072 4489E8   		movl	%r13d, %eax
 883:fltk-1.3.4-1/jpeg/jmemmgr.c ****     }
 1002              		.loc 1 883 0
 1003 0075 4829D0   		subq	%rdx, %rax
 1004 0078 BA000000 		movl	$0, %edx
 1004      00
 1005 007d 480F48C2 		cmovs	%rdx, %rax
 1006 0081 89431C   		movl	%eax, 28(%rbx)
 1007              	.L87:
 1008              	.LBE25:
 889:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
 1009              		.loc 1 889 0
 1010 0084 31D2     		xorl	%edx, %edx
 1011 0086 4889DE   		movq	%rbx, %rsi
 1012 0089 4C89F7   		movq	%r14, %rdi
 1013 008c E8000000 		call	do_barray_io
 1013      00
 1014              	.LVL118:
 1015              	.L83:
 895:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (ptr->first_undef_row < start_row) {
 1016              		.loc 1 895 0
 1017 0091 8B6B20   		movl	32(%rbx), %ebp
 1018 0094 4139ED   		cmpl	%ebp, %r13d
 1019 0097 7652     		jbe	.L88
 896:fltk-1.3.4-1/jpeg/jmemmgr.c ****       if (writable)		/* writer skipped over a section of array */
 1020              		.loc 1 896 0
 1021 0099 4139EC   		cmpl	%ebp, %r12d
 1022 009c 0F869E00 		jbe	.L89
 1022      0000
 897:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 1023              		.loc 1 897 0
 1024 00a2 4585FF   		testl	%r15d, %r15d
 1025 00a5 4489E5   		movl	%r12d, %ebp
 1026 00a8 0F85F200 		jne	.L114
 1026      0000
 1027              	.L90:
 905:fltk-1.3.4-1/jpeg/jmemmgr.c ****       size_t bytesperrow = (size_t) ptr->blocksperrow * SIZEOF(JBLOCK);
 1028              		.loc 1 905 0
 1029 00ae 8B5324   		movl	36(%rbx), %edx
 1030 00b1 85D2     		testl	%edx, %edx
 1031 00b3 0F84FF00 		je	.L115
 1031      0000
 1032              	.L96:
 1033              	.LBB26:
 907:fltk-1.3.4-1/jpeg/jmemmgr.c ****       end_row -= ptr->cur_start_row;
 1034              		.loc 1 907 0
 1035 00b9 8B431C   		movl	28(%rbx), %eax
 906:fltk-1.3.4-1/jpeg/jmemmgr.c ****       undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
 1036              		.loc 1 906 0
 1037 00bc 448B730C 		movl	12(%rbx), %r14d
 1038              	.LVL119:
 907:fltk-1.3.4-1/jpeg/jmemmgr.c ****       end_row -= ptr->cur_start_row;
 1039              		.loc 1 907 0
 1040 00c0 29C5     		subl	%eax, %ebp
 908:fltk-1.3.4-1/jpeg/jmemmgr.c ****       while (undef_row < end_row) {
 1041              		.loc 1 908 0
 1042 00c2 4129C5   		subl	%eax, %r13d
 1043              	.LVL120:
 906:fltk-1.3.4-1/jpeg/jmemmgr.c ****       undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
 1044              		.loc 1 906 0
 1045 00c5 49C1E607 		salq	$7, %r14
 1046              	.LVL121:
 909:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	FMEMZERO((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
 1047              		.loc 1 909 0
 1048 00c9 4439ED   		cmpl	%r13d, %ebp
 1049 00cc 7320     		jnb	.L92
 1050 00ce 6690     		.p2align 4,,10
 1051              		.p2align 3
 1052              	.L93:
 1053              	.LVL122:
 910:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	undef_row++;
 1054              		.loc 1 910 0
 1055 00d0 488B03   		movq	(%rbx), %rax
 1056 00d3 89EA     		movl	%ebp, %edx
 1057              	.LBB27:
 1058              	.LBB28:
 1059              		.file 2 "/usr/include/x86_64-linux-gnu/bits/string3.h"
   1:/usr/include/x86_64-linux-gnu/bits/string3.h **** /* Copyright (C) 2004-2016 Free Software Foundation, Inc.
   2:/usr/include/x86_64-linux-gnu/bits/string3.h ****    This file is part of the GNU C Library.
   3:/usr/include/x86_64-linux-gnu/bits/string3.h **** 
   4:/usr/include/x86_64-linux-gnu/bits/string3.h ****    The GNU C Library is free software; you can redistribute it and/or
   5:/usr/include/x86_64-linux-gnu/bits/string3.h ****    modify it under the terms of the GNU Lesser General Public
   6:/usr/include/x86_64-linux-gnu/bits/string3.h ****    License as published by the Free Software Foundation; either
   7:/usr/include/x86_64-linux-gnu/bits/string3.h ****    version 2.1 of the License, or (at your option) any later version.
   8:/usr/include/x86_64-linux-gnu/bits/string3.h **** 
   9:/usr/include/x86_64-linux-gnu/bits/string3.h ****    The GNU C Library is distributed in the hope that it will be useful,
  10:/usr/include/x86_64-linux-gnu/bits/string3.h ****    but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:/usr/include/x86_64-linux-gnu/bits/string3.h ****    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12:/usr/include/x86_64-linux-gnu/bits/string3.h ****    Lesser General Public License for more details.
  13:/usr/include/x86_64-linux-gnu/bits/string3.h **** 
  14:/usr/include/x86_64-linux-gnu/bits/string3.h ****    You should have received a copy of the GNU Lesser General Public
  15:/usr/include/x86_64-linux-gnu/bits/string3.h ****    License along with the GNU C Library; if not, see
  16:/usr/include/x86_64-linux-gnu/bits/string3.h ****    <http://www.gnu.org/licenses/>.  */
  17:/usr/include/x86_64-linux-gnu/bits/string3.h **** 
  18:/usr/include/x86_64-linux-gnu/bits/string3.h **** #ifndef _STRING_H
  19:/usr/include/x86_64-linux-gnu/bits/string3.h **** # error "Never use <bits/string3.h> directly; include <string.h> instead."
  20:/usr/include/x86_64-linux-gnu/bits/string3.h **** #endif
  21:/usr/include/x86_64-linux-gnu/bits/string3.h **** 
  22:/usr/include/x86_64-linux-gnu/bits/string3.h **** #if !__GNUC_PREREQ (5,0)
  23:/usr/include/x86_64-linux-gnu/bits/string3.h **** __warndecl (__warn_memset_zero_len,
  24:/usr/include/x86_64-linux-gnu/bits/string3.h **** 	    "memset used with constant zero length parameter; this could be due to transposed parameters")
  25:/usr/include/x86_64-linux-gnu/bits/string3.h **** #endif
  26:/usr/include/x86_64-linux-gnu/bits/string3.h **** 
  27:/usr/include/x86_64-linux-gnu/bits/string3.h **** #ifndef __cplusplus
  28:/usr/include/x86_64-linux-gnu/bits/string3.h **** /* XXX This is temporarily.  We should not redefine any of the symbols
  29:/usr/include/x86_64-linux-gnu/bits/string3.h ****    and instead integrate the error checking into the original
  30:/usr/include/x86_64-linux-gnu/bits/string3.h ****    definitions.  */
  31:/usr/include/x86_64-linux-gnu/bits/string3.h **** # undef memcpy
  32:/usr/include/x86_64-linux-gnu/bits/string3.h **** # undef memmove
  33:/usr/include/x86_64-linux-gnu/bits/string3.h **** # undef memset
  34:/usr/include/x86_64-linux-gnu/bits/string3.h **** # undef strcat
  35:/usr/include/x86_64-linux-gnu/bits/string3.h **** # undef strcpy
  36:/usr/include/x86_64-linux-gnu/bits/string3.h **** # undef strncat
  37:/usr/include/x86_64-linux-gnu/bits/string3.h **** # undef strncpy
  38:/usr/include/x86_64-linux-gnu/bits/string3.h **** # ifdef __USE_GNU
  39:/usr/include/x86_64-linux-gnu/bits/string3.h **** #  undef mempcpy
  40:/usr/include/x86_64-linux-gnu/bits/string3.h **** #  undef stpcpy
  41:/usr/include/x86_64-linux-gnu/bits/string3.h **** # endif
  42:/usr/include/x86_64-linux-gnu/bits/string3.h **** # ifdef __USE_MISC
  43:/usr/include/x86_64-linux-gnu/bits/string3.h **** #  undef bcopy
  44:/usr/include/x86_64-linux-gnu/bits/string3.h **** #  undef bzero
  45:/usr/include/x86_64-linux-gnu/bits/string3.h **** # endif
  46:/usr/include/x86_64-linux-gnu/bits/string3.h **** #endif
  47:/usr/include/x86_64-linux-gnu/bits/string3.h **** 
  48:/usr/include/x86_64-linux-gnu/bits/string3.h **** 
  49:/usr/include/x86_64-linux-gnu/bits/string3.h **** __fortify_function void *
  50:/usr/include/x86_64-linux-gnu/bits/string3.h **** __NTH (memcpy (void *__restrict __dest, const void *__restrict __src,
  51:/usr/include/x86_64-linux-gnu/bits/string3.h **** 	       size_t __len))
  52:/usr/include/x86_64-linux-gnu/bits/string3.h **** {
  53:/usr/include/x86_64-linux-gnu/bits/string3.h ****   return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
  54:/usr/include/x86_64-linux-gnu/bits/string3.h **** }
  55:/usr/include/x86_64-linux-gnu/bits/string3.h **** 
  56:/usr/include/x86_64-linux-gnu/bits/string3.h **** __fortify_function void *
  57:/usr/include/x86_64-linux-gnu/bits/string3.h **** __NTH (memmove (void *__dest, const void *__src, size_t __len))
  58:/usr/include/x86_64-linux-gnu/bits/string3.h **** {
  59:/usr/include/x86_64-linux-gnu/bits/string3.h ****   return __builtin___memmove_chk (__dest, __src, __len, __bos0 (__dest));
  60:/usr/include/x86_64-linux-gnu/bits/string3.h **** }
  61:/usr/include/x86_64-linux-gnu/bits/string3.h **** 
  62:/usr/include/x86_64-linux-gnu/bits/string3.h **** #ifdef __USE_GNU
  63:/usr/include/x86_64-linux-gnu/bits/string3.h **** __fortify_function void *
  64:/usr/include/x86_64-linux-gnu/bits/string3.h **** __NTH (mempcpy (void *__restrict __dest, const void *__restrict __src,
  65:/usr/include/x86_64-linux-gnu/bits/string3.h **** 		size_t __len))
  66:/usr/include/x86_64-linux-gnu/bits/string3.h **** {
  67:/usr/include/x86_64-linux-gnu/bits/string3.h ****   return __builtin___mempcpy_chk (__dest, __src, __len, __bos0 (__dest));
  68:/usr/include/x86_64-linux-gnu/bits/string3.h **** }
  69:/usr/include/x86_64-linux-gnu/bits/string3.h **** #endif
  70:/usr/include/x86_64-linux-gnu/bits/string3.h **** 
  71:/usr/include/x86_64-linux-gnu/bits/string3.h **** 
  72:/usr/include/x86_64-linux-gnu/bits/string3.h **** /* The first two tests here help to catch a somewhat common problem
  73:/usr/include/x86_64-linux-gnu/bits/string3.h ****    where the second and third parameter are transposed.  This is
  74:/usr/include/x86_64-linux-gnu/bits/string3.h ****    especially problematic if the intended fill value is zero.  In this
  75:/usr/include/x86_64-linux-gnu/bits/string3.h ****    case no work is done at all.  We detect these problems by referring
  76:/usr/include/x86_64-linux-gnu/bits/string3.h ****    non-existing functions.  */
  77:/usr/include/x86_64-linux-gnu/bits/string3.h **** __fortify_function void *
  78:/usr/include/x86_64-linux-gnu/bits/string3.h **** __NTH (memset (void *__dest, int __ch, size_t __len))
  79:/usr/include/x86_64-linux-gnu/bits/string3.h **** {
  80:/usr/include/x86_64-linux-gnu/bits/string3.h ****   /* GCC-5.0 and newer implements these checks in the compiler, so we don't
  81:/usr/include/x86_64-linux-gnu/bits/string3.h ****      need them here.  */
  82:/usr/include/x86_64-linux-gnu/bits/string3.h **** #if !__GNUC_PREREQ (5,0)
  83:/usr/include/x86_64-linux-gnu/bits/string3.h ****   if (__builtin_constant_p (__len) && __len == 0
  84:/usr/include/x86_64-linux-gnu/bits/string3.h ****       && (!__builtin_constant_p (__ch) || __ch != 0))
  85:/usr/include/x86_64-linux-gnu/bits/string3.h ****     {
  86:/usr/include/x86_64-linux-gnu/bits/string3.h ****       __warn_memset_zero_len ();
  87:/usr/include/x86_64-linux-gnu/bits/string3.h ****       return __dest;
  88:/usr/include/x86_64-linux-gnu/bits/string3.h ****     }
  89:/usr/include/x86_64-linux-gnu/bits/string3.h **** #endif
  90:/usr/include/x86_64-linux-gnu/bits/string3.h ****   return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
 1060              		.loc 2 90 0
 1061 00d5 31F6     		xorl	%esi, %esi
 1062              	.LBE28:
 1063              	.LBE27:
 911:fltk-1.3.4-1/jpeg/jmemmgr.c ****       }
 1064              		.loc 1 911 0
 1065 00d7 83C501   		addl	$1, %ebp
 1066              	.LVL123:
 1067              	.LBB30:
 1068              	.LBB29:
 1069              		.loc 2 90 0
 1070 00da 488B3CD0 		movq	(%rax,%rdx,8), %rdi
 1071 00de 4C89F2   		movq	%r14, %rdx
 1072 00e1 E8000000 		call	memset
 1072      00
 1073              	.LVL124:
 1074              	.LBE29:
 1075              	.LBE30:
 909:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	FMEMZERO((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
 1076              		.loc 1 909 0
 1077 00e6 4139ED   		cmpl	%ebp, %r13d
 1078 00e9 77E5     		ja	.L93
 1079              	.LVL125:
 1080              	.L88:
 1081 00eb 8B431C   		movl	28(%rbx), %eax
 1082              	.L92:
 1083              	.LBE26:
 919:fltk-1.3.4-1/jpeg/jmemmgr.c ****     ptr->dirty = TRUE;
 1084              		.loc 1 919 0
 1085 00ee 4585FF   		testl	%r15d, %r15d
 1086 00f1 7407     		je	.L95
 1087              	.L94:
 920:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Return address of proper part of the buffer */
 1088              		.loc 1 920 0
 1089 00f3 C7432801 		movl	$1, 40(%rbx)
 1089      000000
 1090              	.L95:
 922:fltk-1.3.4-1/jpeg/jmemmgr.c **** }
 1091              		.loc 1 922 0
 1092 00fa 4129C4   		subl	%eax, %r12d
 1093              	.LVL126:
 1094 00fd 488B03   		movq	(%rbx), %rax
 923:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 1095              		.loc 1 923 0
 1096 0100 4883C408 		addq	$8, %rsp
 1097              		.cfi_remember_state
 1098              		.cfi_def_cfa_offset 56
 1099 0104 5B       		popq	%rbx
 1100              		.cfi_def_cfa_offset 48
 1101              	.LVL127:
 1102 0105 5D       		popq	%rbp
 1103              		.cfi_def_cfa_offset 40
 922:fltk-1.3.4-1/jpeg/jmemmgr.c **** }
 1104              		.loc 1 922 0
 1105 0106 4A8D04E0 		leaq	(%rax,%r12,8), %rax
 923:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 1106              		.loc 1 923 0
 1107 010a 415C     		popq	%r12
 1108              		.cfi_def_cfa_offset 32
 1109 010c 415D     		popq	%r13
 1110              		.cfi_def_cfa_offset 24
 1111              	.LVL128:
 1112 010e 415E     		popq	%r14
 1113              		.cfi_def_cfa_offset 16
 1114 0110 415F     		popq	%r15
 1115              		.cfi_def_cfa_offset 8
 1116              	.LVL129:
 1117 0112 C3       		ret
 1118              	.LVL130:
 1119              		.p2align 4,,10
 1120 0113 0F1F4400 		.p2align 3
 1120      00
 1121              	.L113:
 1122              		.cfi_restore_state
 875:fltk-1.3.4-1/jpeg/jmemmgr.c ****     } else {
 1123              		.loc 1 875 0
 1124 0118 4489631C 		movl	%r12d, 28(%rbx)
 1125 011c E963FFFF 		jmp	.L87
 1125      FF
 1126              	.LVL131:
 1127              		.p2align 4,,10
 1128 0121 0F1F8000 		.p2align 3
 1128      000000
 1129              	.L110:
 853:fltk-1.3.4-1/jpeg/jmemmgr.c ****       ptr->mem_buffer == NULL)
 1130              		.loc 1 853 0 discriminator 2
 1131 0128 48833E00 		cmpq	$0, (%rsi)
 1132 012c 0F850DFF 		jne	.L81
 1132      FFFF
 1133 0132 E9F6FEFF 		jmp	.L80
 1133      FF
 1134              	.LVL132:
 1135 0137 660F1F84 		.p2align 4,,10
 1135      00000000 
 1135      00
 1136              		.p2align 3
 1137              	.L89:
 903:fltk-1.3.4-1/jpeg/jmemmgr.c ****       ptr->first_undef_row = end_row;
 1138              		.loc 1 903 0
 1139 0140 4585FF   		testl	%r15d, %r15d
 1140 0143 0F8465FF 		je	.L90
 1140      FFFF
 1141              	.L91:
 905:fltk-1.3.4-1/jpeg/jmemmgr.c ****       size_t bytesperrow = (size_t) ptr->blocksperrow * SIZEOF(JBLOCK);
 1142              		.loc 1 905 0
 1143 0149 8B4324   		movl	36(%rbx), %eax
 904:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (ptr->pre_zero) {
 1144              		.loc 1 904 0
 1145 014c 44896B20 		movl	%r13d, 32(%rbx)
 905:fltk-1.3.4-1/jpeg/jmemmgr.c ****       size_t bytesperrow = (size_t) ptr->blocksperrow * SIZEOF(JBLOCK);
 1146              		.loc 1 905 0
 1147 0150 85C0     		testl	%eax, %eax
 1148 0152 0F8561FF 		jne	.L96
 1148      FFFF
 1149 0158 8B431C   		movl	28(%rbx), %eax
 1150 015b EB96     		jmp	.L94
 1151              	.LVL133:
 1152 015d 0F1F00   		.p2align 4,,10
 1153              		.p2align 3
 1154              	.L112:
 864:fltk-1.3.4-1/jpeg/jmemmgr.c ****       ptr->dirty = FALSE;
 1155              		.loc 1 864 0
 1156 0160 BA010000 		movl	$1, %edx
 1156      00
 1157 0165 4889DE   		movq	%rbx, %rsi
 1158 0168 4C89F7   		movq	%r14, %rdi
 1159 016b E8000000 		call	do_barray_io
 1159      00
 1160              	.LVL134:
 865:fltk-1.3.4-1/jpeg/jmemmgr.c ****     }
 1161              		.loc 1 865 0
 1162 0170 C7432800 		movl	$0, 40(%rbx)
 1162      000000
 1163 0177 E9E9FEFF 		jmp	.L85
 1163      FF
 1164 017c 0F1F4000 		.p2align 4,,10
 1165              		.p2align 3
 1166              	.L111:
 861:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Flush old buffer contents if necessary */
 1167              		.loc 1 861 0
 1168 0180 498B06   		movq	(%r14), %rax
 1169 0183 4C89F7   		movq	%r14, %rdi
 1170 0186 C7402847 		movl	$71, 40(%rax)
 1170      000000
 1171 018d 498B06   		movq	(%r14), %rax
 1172 0190 FF10     		call	*(%rax)
 1173              	.LVL135:
 1174 0192 E9C3FEFF 		jmp	.L84
 1174      FF
 1175              	.LVL136:
 1176 0197 660F1F84 		.p2align 4,,10
 1176      00000000 
 1176      00
 1177              		.p2align 3
 1178              	.L114:
 898:fltk-1.3.4-1/jpeg/jmemmgr.c ****       undef_row = start_row;	/* but reader is allowed to read ahead */
 1179              		.loc 1 898 0
 1180 01a0 498B06   		movq	(%r14), %rax
 1181 01a3 4C89F7   		movq	%r14, %rdi
 1182 01a6 C7402817 		movl	$23, 40(%rax)
 1182      000000
 1183 01ad 498B06   		movq	(%r14), %rax
 1184 01b0 FF10     		call	*(%rax)
 1185              	.LVL137:
 1186 01b2 EB95     		jmp	.L91
 1187              	.LVL138:
 1188              		.p2align 4,,10
 1189 01b4 0F1F4000 		.p2align 3
 1190              	.L115:
 915:fltk-1.3.4-1/jpeg/jmemmgr.c ****     }
 1191              		.loc 1 915 0
 1192 01b8 498B06   		movq	(%r14), %rax
 1193 01bb 4C89F7   		movq	%r14, %rdi
 1194 01be C7402817 		movl	$23, 40(%rax)
 1194      000000
 1195 01c5 498B06   		movq	(%r14), %rax
 1196 01c8 FF10     		call	*(%rax)
 1197              	.LVL139:
 1198 01ca 8B431C   		movl	28(%rbx), %eax
 1199 01cd E928FFFF 		jmp	.L95
 1199      FF
 1200              		.cfi_endproc
 1201              	.LFE72:
 1203              		.section	.text.unlikely.access_virt_barray
 1204              	.LCOLDE6:
 1205              		.section	.text.access_virt_barray
 1206              	.LHOTE6:
 1207              		.section	.text.unlikely.alloc_large,"ax",@progbits
 1208              	.LCOLDB7:
 1209              		.section	.text.alloc_large,"ax",@progbits
 1210              	.LHOTB7:
 1211              		.p2align 4,,15
 1213              	alloc_large:
 1214              	.LFB63:
 345:fltk-1.3.4-1/jpeg/jmemmgr.c ****   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 1215              		.loc 1 345 0
 1216              		.cfi_startproc
 1217              	.LVL140:
 1218 0000 4155     		pushq	%r13
 1219              		.cfi_def_cfa_offset 16
 1220              		.cfi_offset 13, -16
 1221 0002 4154     		pushq	%r12
 1222              		.cfi_def_cfa_offset 24
 1223              		.cfi_offset 12, -24
 1224 0004 4C63E6   		movslq	%esi, %r12
 1225 0007 55       		pushq	%rbp
 1226              		.cfi_def_cfa_offset 32
 1227              		.cfi_offset 6, -32
 1228 0008 53       		pushq	%rbx
 1229              		.cfi_def_cfa_offset 40
 1230              		.cfi_offset 3, -40
 1231 0009 4889FD   		movq	%rdi, %rbp
 1232 000c 4889D3   		movq	%rdx, %rbx
 1233 000f 4883EC18 		subq	$24, %rsp
 1234              		.cfi_def_cfa_offset 64
 351:fltk-1.3.4-1/jpeg/jmemmgr.c ****     out_of_memory(cinfo, 3);	/* request exceeds malloc's ability */
 1235              		.loc 1 351 0
 1236 0013 4881FAE8 		cmpq	$999999976, %rdx
 1236      C99A3B
 346:fltk-1.3.4-1/jpeg/jmemmgr.c ****   large_pool_ptr hdr_ptr;
 1237              		.loc 1 346 0
 1238 001a 4C8B6F08 		movq	8(%rdi), %r13
 1239              	.LVL141:
 351:fltk-1.3.4-1/jpeg/jmemmgr.c ****     out_of_memory(cinfo, 3);	/* request exceeds malloc's ability */
 1240              		.loc 1 351 0
 1241 001e 0F878400 		ja	.L125
 1241      0000
 1242              	.LVL142:
 1243              	.L117:
 356:fltk-1.3.4-1/jpeg/jmemmgr.c ****     sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
 1244              		.loc 1 356 0
 1245 0024 4889D8   		movq	%rbx, %rax
 1246 0027 83E007   		andl	$7, %eax
 1247              	.LVL143:
 1248 002a 7407     		je	.L118
 1249 002c 4883C308 		addq	$8, %rbx
 1250              	.LVL144:
 357:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 1251              		.loc 1 357 0
 1252 0030 4829C3   		subq	%rax, %rbx
 1253              	.LVL145:
 1254              	.L118:
 360:fltk-1.3.4-1/jpeg/jmemmgr.c ****     ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
 1255              		.loc 1 360 0
 1256 0033 4183FC01 		cmpl	$1, %r12d
 1257 0037 761C     		jbe	.L119
 361:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 1258              		.loc 1 361 0
 1259 0039 488B4500 		movq	0(%rbp), %rax
 1260              	.LVL146:
 1261 003d 4889EF   		movq	%rbp, %rdi
 1262 0040 C740280F 		movl	$15, 40(%rax)
 1262      000000
 1263 0047 488B4500 		movq	0(%rbp), %rax
 1264 004b 4489602C 		movl	%r12d, 44(%rax)
 1265 004f 488B4500 		movq	0(%rbp), %rax
 1266 0053 FF10     		call	*(%rax)
 1267              	.LVL147:
 1268              	.L119:
 363:fltk-1.3.4-1/jpeg/jmemmgr.c **** 					    SIZEOF(large_pool_hdr));
 1269              		.loc 1 363 0
 1270 0055 488D7318 		leaq	24(%rbx), %rsi
 1271 0059 4889EF   		movq	%rbp, %rdi
 1272 005c E8000000 		call	jpeg_get_large
 1272      00
 1273              	.LVL148:
 365:fltk-1.3.4-1/jpeg/jmemmgr.c ****     out_of_memory(cinfo, 4);	/* jpeg_get_large failed */
 1274              		.loc 1 365 0
 1275 0061 4885C0   		testq	%rax, %rax
 1276 0064 746A     		je	.L126
 1277              	.LVL149:
 1278              	.L120:
 367:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 1279              		.loc 1 367 0
 1280 0066 498B9598 		movq	152(%r13), %rdx
 1280      000000
 1281 006d 488D5413 		leaq	24(%rbx,%rdx), %rdx
 1281      18
 1282 0072 49899598 		movq	%rdx, 152(%r13)
 1282      000000
 1283 0079 4B8D54E5 		leaq	0(%r13,%r12,8), %rdx
 1283      00
 370:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* We maintain space counts in each pool header for statistical purposes,
 1284              		.loc 1 370 0
 1285 007e 488B4A78 		movq	120(%rdx), %rcx
 374:fltk-1.3.4-1/jpeg/jmemmgr.c ****   hdr_ptr->hdr.bytes_left = 0;
 1286              		.loc 1 374 0
 1287 0082 48895808 		movq	%rbx, 8(%rax)
 375:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->large_list[pool_id] = hdr_ptr;
 1288              		.loc 1 375 0
 1289 0086 48C74010 		movq	$0, 16(%rax)
 1289      00000000 
 370:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* We maintain space counts in each pool header for statistical purposes,
 1290              		.loc 1 370 0
 1291 008e 488908   		movq	%rcx, (%rax)
 376:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 1292              		.loc 1 376 0
 1293 0091 48894278 		movq	%rax, 120(%rdx)
 379:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 1294              		.loc 1 379 0
 1295 0095 4883C418 		addq	$24, %rsp
 1296              		.cfi_remember_state
 1297              		.cfi_def_cfa_offset 40
 1298 0099 5B       		popq	%rbx
 1299              		.cfi_def_cfa_offset 32
 1300              	.LVL150:
 378:fltk-1.3.4-1/jpeg/jmemmgr.c **** }
 1301              		.loc 1 378 0
 1302 009a 4883C018 		addq	$24, %rax
 379:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 1303              		.loc 1 379 0
 1304 009e 5D       		popq	%rbp
 1305              		.cfi_def_cfa_offset 24
 1306              	.LVL151:
 1307 009f 415C     		popq	%r12
 1308              		.cfi_def_cfa_offset 16
 1309              	.LVL152:
 1310 00a1 415D     		popq	%r13
 1311              		.cfi_def_cfa_offset 8
 1312              	.LVL153:
 1313 00a3 C3       		ret
 1314              	.LVL154:
 1315              		.p2align 4,,10
 1316 00a4 0F1F4000 		.p2align 3
 1317              	.L125:
 1318              		.cfi_restore_state
 1319              	.LBB31:
 1320              	.LBB32:
 225:fltk-1.3.4-1/jpeg/jmemmgr.c **** }
 1321              		.loc 1 225 0
 1322 00a8 488B07   		movq	(%rdi), %rax
 1323 00ab C7402838 		movl	$56, 40(%rax)
 1323      000000
 1324 00b2 488B07   		movq	(%rdi), %rax
 1325 00b5 C7402C03 		movl	$3, 44(%rax)
 1325      000000
 1326 00bc 488B07   		movq	(%rdi), %rax
 1327 00bf FF10     		call	*(%rax)
 1328              	.LVL155:
 1329 00c1 E95EFFFF 		jmp	.L117
 1329      FF
 1330              	.LVL156:
 1331 00c6 662E0F1F 		.p2align 4,,10
 1331      84000000 
 1331      0000
 1332              		.p2align 3
 1333              	.L126:
 1334              	.LBE32:
 1335              	.LBE31:
 1336              	.LBB33:
 1337              	.LBB34:
 1338 00d0 488B5500 		movq	0(%rbp), %rdx
 1339 00d4 48894424 		movq	%rax, 8(%rsp)
 1339      08
 1340              	.LVL157:
 1341 00d9 4889EF   		movq	%rbp, %rdi
 1342 00dc C7422838 		movl	$56, 40(%rdx)
 1342      000000
 1343 00e3 488B5500 		movq	0(%rbp), %rdx
 1344 00e7 C7422C04 		movl	$4, 44(%rdx)
 1344      000000
 1345 00ee 488B5500 		movq	0(%rbp), %rdx
 1346 00f2 FF12     		call	*(%rdx)
 1347              	.LVL158:
 1348 00f4 488B4424 		movq	8(%rsp), %rax
 1348      08
 1349 00f9 E968FFFF 		jmp	.L120
 1349      FF
 1350              	.LBE34:
 1351              	.LBE33:
 1352              		.cfi_endproc
 1353              	.LFE63:
 1355              		.section	.text.unlikely.alloc_large
 1356              	.LCOLDE7:
 1357              		.section	.text.alloc_large
 1358              	.LHOTE7:
 1359              		.section	.text.unlikely.alloc_barray,"ax",@progbits
 1360              	.LCOLDB8:
 1361              		.section	.text.alloc_barray,"ax",@progbits
 1362              	.LHOTB8:
 1363              		.p2align 4,,15
 1365              	alloc_barray:
 1366              	.LFB65:
 447:fltk-1.3.4-1/jpeg/jmemmgr.c ****   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 1367              		.loc 1 447 0
 1368              		.cfi_startproc
 1369              	.LVL159:
 1370 0000 4157     		pushq	%r15
 1371              		.cfi_def_cfa_offset 16
 1372              		.cfi_offset 15, -16
 1373 0002 4156     		pushq	%r14
 1374              		.cfi_def_cfa_offset 24
 1375              		.cfi_offset 14, -24
 455:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	  ((long) blocksperrow * SIZEOF(JBLOCK));
 1376              		.loc 1 455 0
 1377 0004 B8E8C99A 		movl	$999999976, %eax
 1377      3B
 447:fltk-1.3.4-1/jpeg/jmemmgr.c ****   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 1378              		.loc 1 447 0
 1379 0009 4155     		pushq	%r13
 1380              		.cfi_def_cfa_offset 32
 1381              		.cfi_offset 13, -32
 1382 000b 4154     		pushq	%r12
 1383              		.cfi_def_cfa_offset 40
 1384              		.cfi_offset 12, -40
 1385 000d 4189CD   		movl	%ecx, %r13d
 1386 0010 55       		pushq	%rbp
 1387              		.cfi_def_cfa_offset 48
 1388              		.cfi_offset 6, -48
 456:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (ltemp <= 0)
 1389              		.loc 1 456 0
 1390 0011 89D5     		movl	%edx, %ebp
 455:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	  ((long) blocksperrow * SIZEOF(JBLOCK));
 1391              		.loc 1 455 0
 1392 0013 31D2     		xorl	%edx, %edx
 1393              	.LVL160:
 456:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (ltemp <= 0)
 1394              		.loc 1 456 0
 1395 0015 48C1E507 		salq	$7, %rbp
 1396              	.LVL161:
 447:fltk-1.3.4-1/jpeg/jmemmgr.c ****   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 1397              		.loc 1 447 0
 1398 0019 53       		pushq	%rbx
 1399              		.cfi_def_cfa_offset 56
 1400              		.cfi_offset 3, -56
 1401 001a 4989FC   		movq	%rdi, %r12
 455:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	  ((long) blocksperrow * SIZEOF(JBLOCK));
 1402              		.loc 1 455 0
 1403 001d 48F7F5   		divq	%rbp
 447:fltk-1.3.4-1/jpeg/jmemmgr.c ****   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 1404              		.loc 1 447 0
 1405 0020 4883EC18 		subq	$24, %rsp
 1406              		.cfi_def_cfa_offset 80
 448:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JBLOCKARRAY result;
 1407              		.loc 1 448 0
 1408 0024 488B5F08 		movq	8(%rdi), %rbx
 1409              	.LVL162:
 447:fltk-1.3.4-1/jpeg/jmemmgr.c ****   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 1410              		.loc 1 447 0
 1411 0028 89742404 		movl	%esi, 4(%rsp)
 457:fltk-1.3.4-1/jpeg/jmemmgr.c ****     ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
 1412              		.loc 1 457 0
 1413 002c 4885C0   		testq	%rax, %rax
 1414 002f 0F848200 		je	.L144
 1414      0000
 1415              	.LVL163:
 1416              	.L128:
 459:fltk-1.3.4-1/jpeg/jmemmgr.c ****     rowsperchunk = (JDIMENSION) ltemp;
 1417              		.loc 1 459 0
 1418 0035 4489EA   		movl	%r13d, %edx
 460:fltk-1.3.4-1/jpeg/jmemmgr.c ****   else
 1419              		.loc 1 460 0
 1420 0038 4189C7   		movl	%eax, %r15d
 466:fltk-1.3.4-1/jpeg/jmemmgr.c **** 				     (size_t) (numrows * SIZEOF(JBLOCKROW)));
 1421              		.loc 1 466 0
 1422 003b 8B742404 		movl	4(%rsp), %esi
 460:fltk-1.3.4-1/jpeg/jmemmgr.c ****   else
 1423              		.loc 1 460 0
 1424 003f 4839D0   		cmpq	%rdx, %rax
 466:fltk-1.3.4-1/jpeg/jmemmgr.c **** 				     (size_t) (numrows * SIZEOF(JBLOCKROW)));
 1425              		.loc 1 466 0
 1426 0042 4C89E7   		movq	%r12, %rdi
 460:fltk-1.3.4-1/jpeg/jmemmgr.c ****   else
 1427              		.loc 1 460 0
 1428 0045 450F4DFD 		cmovge	%r13d, %r15d
 1429              	.LVL164:
 466:fltk-1.3.4-1/jpeg/jmemmgr.c **** 				     (size_t) (numrows * SIZEOF(JBLOCKROW)));
 1430              		.loc 1 466 0
 1431 0049 48C1E203 		salq	$3, %rdx
 463:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 1432              		.loc 1 463 0
 1433 004d 4489BBA0 		movl	%r15d, 160(%rbx)
 1433      000000
 471:fltk-1.3.4-1/jpeg/jmemmgr.c ****     rowsperchunk = MIN(rowsperchunk, numrows - currow);
 1434              		.loc 1 471 0
 1435 0054 31DB     		xorl	%ebx, %ebx
 1436              	.LVL165:
 466:fltk-1.3.4-1/jpeg/jmemmgr.c **** 				     (size_t) (numrows * SIZEOF(JBLOCKROW)));
 1437              		.loc 1 466 0
 1438 0056 E8000000 		call	alloc_small
 1438      00
 1439              	.LVL166:
 471:fltk-1.3.4-1/jpeg/jmemmgr.c ****     rowsperchunk = MIN(rowsperchunk, numrows - currow);
 1440              		.loc 1 471 0
 1441 005b 4585ED   		testl	%r13d, %r13d
 466:fltk-1.3.4-1/jpeg/jmemmgr.c **** 				     (size_t) (numrows * SIZEOF(JBLOCKROW)));
 1442              		.loc 1 466 0
 1443 005e 4989C6   		movq	%rax, %r14
 1444              	.LVL167:
 471:fltk-1.3.4-1/jpeg/jmemmgr.c ****     rowsperchunk = MIN(rowsperchunk, numrows - currow);
 1445              		.loc 1 471 0
 1446 0061 7442     		je	.L142
 1447              	.LVL168:
 1448              		.p2align 4,,10
 1449 0063 0F1F4400 		.p2align 3
 1449      00
 1450              	.L138:
 472:fltk-1.3.4-1/jpeg/jmemmgr.c ****     workspace = (JBLOCKROW) alloc_large(cinfo, pool_id,
 1451              		.loc 1 472 0
 1452 0068 4489E8   		movl	%r13d, %eax
 473:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	(size_t) ((size_t) rowsperchunk * (size_t) blocksperrow
 1453              		.loc 1 473 0
 1454 006b 8B742404 		movl	4(%rsp), %esi
 1455 006f 4C89E7   		movq	%r12, %rdi
 472:fltk-1.3.4-1/jpeg/jmemmgr.c ****     workspace = (JBLOCKROW) alloc_large(cinfo, pool_id,
 1456              		.loc 1 472 0
 1457 0072 29D8     		subl	%ebx, %eax
 1458 0074 4139C7   		cmpl	%eax, %r15d
 1459 0077 440F47F8 		cmova	%eax, %r15d
 1460              	.LVL169:
 473:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	(size_t) ((size_t) rowsperchunk * (size_t) blocksperrow
 1461              		.loc 1 473 0
 1462 007b 4489FA   		movl	%r15d, %edx
 1463 007e 480FAFD5 		imulq	%rbp, %rdx
 1464 0082 E8000000 		call	alloc_large
 1464      00
 1465              	.LVL170:
 476:fltk-1.3.4-1/jpeg/jmemmgr.c ****       result[currow++] = workspace;
 1466              		.loc 1 476 0
 1467 0087 4585FF   		testl	%r15d, %r15d
 1468 008a 7414     		je	.L131
 1469 008c 418D341F 		leal	(%r15,%rbx), %esi
 1470              	.LVL171:
 1471              		.p2align 4,,10
 1472              		.p2align 3
 1473              	.L132:
 477:fltk-1.3.4-1/jpeg/jmemmgr.c ****       workspace += blocksperrow;
 1474              		.loc 1 477 0 discriminator 3
 1475 0090 89DA     		movl	%ebx, %edx
 1476 0092 83C301   		addl	$1, %ebx
 1477              	.LVL172:
 1478 0095 498904D6 		movq	%rax, (%r14,%rdx,8)
 478:fltk-1.3.4-1/jpeg/jmemmgr.c ****     }
 1479              		.loc 1 478 0 discriminator 3
 1480 0099 4801E8   		addq	%rbp, %rax
 1481              	.LVL173:
 476:fltk-1.3.4-1/jpeg/jmemmgr.c ****       result[currow++] = workspace;
 1482              		.loc 1 476 0 discriminator 3
 1483 009c 39DE     		cmpl	%ebx, %esi
 1484 009e 75F0     		jne	.L132
 1485              	.L131:
 471:fltk-1.3.4-1/jpeg/jmemmgr.c ****     rowsperchunk = MIN(rowsperchunk, numrows - currow);
 1486              		.loc 1 471 0
 1487 00a0 4139DD   		cmpl	%ebx, %r13d
 1488 00a3 77C3     		ja	.L138
 1489              	.LVL174:
 1490              	.L142:
 483:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 1491              		.loc 1 483 0
 1492 00a5 4883C418 		addq	$24, %rsp
 1493              		.cfi_remember_state
 1494              		.cfi_def_cfa_offset 56
 1495 00a9 4C89F0   		movq	%r14, %rax
 1496 00ac 5B       		popq	%rbx
 1497              		.cfi_def_cfa_offset 48
 1498 00ad 5D       		popq	%rbp
 1499              		.cfi_def_cfa_offset 40
 1500 00ae 415C     		popq	%r12
 1501              		.cfi_def_cfa_offset 32
 1502              	.LVL175:
 1503 00b0 415D     		popq	%r13
 1504              		.cfi_def_cfa_offset 24
 1505              	.LVL176:
 1506 00b2 415E     		popq	%r14
 1507              		.cfi_def_cfa_offset 16
 1508              	.LVL177:
 1509 00b4 415F     		popq	%r15
 1510              		.cfi_def_cfa_offset 8
 1511              	.LVL178:
 1512 00b6 C3       		ret
 1513              	.LVL179:
 1514              	.L144:
 1515              		.cfi_restore_state
 458:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (ltemp < (long) numrows)
 1516              		.loc 1 458 0
 1517 00b7 488B17   		movq	(%rdi), %rdx
 1518 00ba 48894424 		movq	%rax, 8(%rsp)
 1518      08
 1519 00bf C7422848 		movl	$72, 40(%rdx)
 1519      000000
 1520 00c6 488B17   		movq	(%rdi), %rdx
 1521 00c9 FF12     		call	*(%rdx)
 1522              	.LVL180:
 1523 00cb 488B4424 		movq	8(%rsp), %rax
 1523      08
 1524 00d0 E960FFFF 		jmp	.L128
 1524      FF
 1525              		.cfi_endproc
 1526              	.LFE65:
 1528              		.section	.text.unlikely.alloc_barray
 1529              	.LCOLDE8:
 1530              		.section	.text.alloc_barray
 1531              	.LHOTE8:
 1532              		.section	.text.unlikely.alloc_sarray,"ax",@progbits
 1533              	.LCOLDB9:
 1534              		.section	.text.alloc_sarray,"ax",@progbits
 1535              	.LHOTB9:
 1536              		.p2align 4,,15
 1538              	alloc_sarray:
 1539              	.LFB64:
 399:fltk-1.3.4-1/jpeg/jmemmgr.c ****   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 1540              		.loc 1 399 0
 1541              		.cfi_startproc
 1542              	.LVL181:
 1543 0000 4157     		pushq	%r15
 1544              		.cfi_def_cfa_offset 16
 1545              		.cfi_offset 15, -16
 407:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	  ((long) samplesperrow * SIZEOF(JSAMPLE));
 1546              		.loc 1 407 0
 1547 0002 B8E8C99A 		movl	$999999976, %eax
 1547      3B
 399:fltk-1.3.4-1/jpeg/jmemmgr.c ****   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 1548              		.loc 1 399 0
 1549 0007 4156     		pushq	%r14
 1550              		.cfi_def_cfa_offset 24
 1551              		.cfi_offset 14, -24
 1552 0009 4155     		pushq	%r13
 1553              		.cfi_def_cfa_offset 32
 1554              		.cfi_offset 13, -32
 1555 000b 4154     		pushq	%r12
 1556              		.cfi_def_cfa_offset 40
 1557              		.cfi_offset 12, -40
 1558 000d 4189CD   		movl	%ecx, %r13d
 1559 0010 55       		pushq	%rbp
 1560              		.cfi_def_cfa_offset 48
 1561              		.cfi_offset 6, -48
 408:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (ltemp <= 0)
 1562              		.loc 1 408 0
 1563 0011 89D5     		movl	%edx, %ebp
 407:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	  ((long) samplesperrow * SIZEOF(JSAMPLE));
 1564              		.loc 1 407 0
 1565 0013 31D2     		xorl	%edx, %edx
 1566              	.LVL182:
 1567 0015 48F7F5   		divq	%rbp
 399:fltk-1.3.4-1/jpeg/jmemmgr.c ****   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 1568              		.loc 1 399 0
 1569 0018 53       		pushq	%rbx
 1570              		.cfi_def_cfa_offset 56
 1571              		.cfi_offset 3, -56
 1572 0019 4989FC   		movq	%rdi, %r12
 1573 001c 4883EC18 		subq	$24, %rsp
 1574              		.cfi_def_cfa_offset 80
 400:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JSAMPARRAY result;
 1575              		.loc 1 400 0
 1576 0020 488B5F08 		movq	8(%rdi), %rbx
 1577              	.LVL183:
 399:fltk-1.3.4-1/jpeg/jmemmgr.c ****   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 1578              		.loc 1 399 0
 1579 0024 89742404 		movl	%esi, 4(%rsp)
 409:fltk-1.3.4-1/jpeg/jmemmgr.c ****     ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
 1580              		.loc 1 409 0
 1581 0028 4885C0   		testq	%rax, %rax
 1582 002b 0F848600 		je	.L162
 1582      0000
 1583              	.LVL184:
 1584              	.L146:
 411:fltk-1.3.4-1/jpeg/jmemmgr.c ****     rowsperchunk = (JDIMENSION) ltemp;
 1585              		.loc 1 411 0
 1586 0031 4489EA   		movl	%r13d, %edx
 412:fltk-1.3.4-1/jpeg/jmemmgr.c ****   else
 1587              		.loc 1 412 0
 1588 0034 4189C7   		movl	%eax, %r15d
 418:fltk-1.3.4-1/jpeg/jmemmgr.c **** 				    (size_t) (numrows * SIZEOF(JSAMPROW)));
 1589              		.loc 1 418 0
 1590 0037 8B742404 		movl	4(%rsp), %esi
 412:fltk-1.3.4-1/jpeg/jmemmgr.c ****   else
 1591              		.loc 1 412 0
 1592 003b 4839D0   		cmpq	%rdx, %rax
 418:fltk-1.3.4-1/jpeg/jmemmgr.c **** 				    (size_t) (numrows * SIZEOF(JSAMPROW)));
 1593              		.loc 1 418 0
 1594 003e 4C89E7   		movq	%r12, %rdi
 412:fltk-1.3.4-1/jpeg/jmemmgr.c ****   else
 1595              		.loc 1 412 0
 1596 0041 450F4DFD 		cmovge	%r13d, %r15d
 1597              	.LVL185:
 418:fltk-1.3.4-1/jpeg/jmemmgr.c **** 				    (size_t) (numrows * SIZEOF(JSAMPROW)));
 1598              		.loc 1 418 0
 1599 0045 48C1E203 		salq	$3, %rdx
 415:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 1600              		.loc 1 415 0
 1601 0049 4489BBA0 		movl	%r15d, 160(%rbx)
 1601      000000
 423:fltk-1.3.4-1/jpeg/jmemmgr.c ****     rowsperchunk = MIN(rowsperchunk, numrows - currow);
 1602              		.loc 1 423 0
 1603 0050 31DB     		xorl	%ebx, %ebx
 1604              	.LVL186:
 418:fltk-1.3.4-1/jpeg/jmemmgr.c **** 				    (size_t) (numrows * SIZEOF(JSAMPROW)));
 1605              		.loc 1 418 0
 1606 0052 E8000000 		call	alloc_small
 1606      00
 1607              	.LVL187:
 423:fltk-1.3.4-1/jpeg/jmemmgr.c ****     rowsperchunk = MIN(rowsperchunk, numrows - currow);
 1608              		.loc 1 423 0
 1609 0057 4585ED   		testl	%r13d, %r13d
 418:fltk-1.3.4-1/jpeg/jmemmgr.c **** 				    (size_t) (numrows * SIZEOF(JSAMPROW)));
 1610              		.loc 1 418 0
 1611 005a 4989C6   		movq	%rax, %r14
 1612              	.LVL188:
 423:fltk-1.3.4-1/jpeg/jmemmgr.c ****     rowsperchunk = MIN(rowsperchunk, numrows - currow);
 1613              		.loc 1 423 0
 1614 005d 7446     		je	.L160
 1615              	.LVL189:
 1616 005f 90       		.p2align 4,,10
 1617              		.p2align 3
 1618              	.L156:
 424:fltk-1.3.4-1/jpeg/jmemmgr.c ****     workspace = (JSAMPROW) alloc_large(cinfo, pool_id,
 1619              		.loc 1 424 0
 1620 0060 4489E8   		movl	%r13d, %eax
 425:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	(size_t) ((size_t) rowsperchunk * (size_t) samplesperrow
 1621              		.loc 1 425 0
 1622 0063 8B742404 		movl	4(%rsp), %esi
 1623 0067 4C89E7   		movq	%r12, %rdi
 424:fltk-1.3.4-1/jpeg/jmemmgr.c ****     workspace = (JSAMPROW) alloc_large(cinfo, pool_id,
 1624              		.loc 1 424 0
 1625 006a 29D8     		subl	%ebx, %eax
 1626 006c 4139C7   		cmpl	%eax, %r15d
 1627 006f 440F47F8 		cmova	%eax, %r15d
 1628              	.LVL190:
 425:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	(size_t) ((size_t) rowsperchunk * (size_t) samplesperrow
 1629              		.loc 1 425 0
 1630 0073 4489FA   		movl	%r15d, %edx
 1631 0076 480FAFD5 		imulq	%rbp, %rdx
 1632 007a E8000000 		call	alloc_large
 1632      00
 1633              	.LVL191:
 428:fltk-1.3.4-1/jpeg/jmemmgr.c ****       result[currow++] = workspace;
 1634              		.loc 1 428 0
 1635 007f 4585FF   		testl	%r15d, %r15d
 1636 0082 741C     		je	.L149
 1637 0084 418D341F 		leal	(%r15,%rbx), %esi
 1638              	.LVL192:
 1639 0088 0F1F8400 		.p2align 4,,10
 1639      00000000 
 1640              		.p2align 3
 1641              	.L150:
 429:fltk-1.3.4-1/jpeg/jmemmgr.c ****       workspace += samplesperrow;
 1642              		.loc 1 429 0 discriminator 3
 1643 0090 89DA     		movl	%ebx, %edx
 1644 0092 83C301   		addl	$1, %ebx
 1645              	.LVL193:
 1646 0095 498904D6 		movq	%rax, (%r14,%rdx,8)
 430:fltk-1.3.4-1/jpeg/jmemmgr.c ****     }
 1647              		.loc 1 430 0 discriminator 3
 1648 0099 4801E8   		addq	%rbp, %rax
 1649              	.LVL194:
 428:fltk-1.3.4-1/jpeg/jmemmgr.c ****       result[currow++] = workspace;
 1650              		.loc 1 428 0 discriminator 3
 1651 009c 39F3     		cmpl	%esi, %ebx
 1652 009e 75F0     		jne	.L150
 1653              	.L149:
 423:fltk-1.3.4-1/jpeg/jmemmgr.c ****     rowsperchunk = MIN(rowsperchunk, numrows - currow);
 1654              		.loc 1 423 0
 1655 00a0 4139DD   		cmpl	%ebx, %r13d
 1656 00a3 77BB     		ja	.L156
 1657              	.LVL195:
 1658              	.L160:
 435:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 1659              		.loc 1 435 0
 1660 00a5 4883C418 		addq	$24, %rsp
 1661              		.cfi_remember_state
 1662              		.cfi_def_cfa_offset 56
 1663 00a9 4C89F0   		movq	%r14, %rax
 1664 00ac 5B       		popq	%rbx
 1665              		.cfi_def_cfa_offset 48
 1666 00ad 5D       		popq	%rbp
 1667              		.cfi_def_cfa_offset 40
 1668              	.LVL196:
 1669 00ae 415C     		popq	%r12
 1670              		.cfi_def_cfa_offset 32
 1671              	.LVL197:
 1672 00b0 415D     		popq	%r13
 1673              		.cfi_def_cfa_offset 24
 1674              	.LVL198:
 1675 00b2 415E     		popq	%r14
 1676              		.cfi_def_cfa_offset 16
 1677              	.LVL199:
 1678 00b4 415F     		popq	%r15
 1679              		.cfi_def_cfa_offset 8
 1680              	.LVL200:
 1681 00b6 C3       		ret
 1682              	.LVL201:
 1683              	.L162:
 1684              		.cfi_restore_state
 410:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (ltemp < (long) numrows)
 1685              		.loc 1 410 0
 1686 00b7 488B17   		movq	(%rdi), %rdx
 1687 00ba 48894424 		movq	%rax, 8(%rsp)
 1687      08
 1688 00bf C7422848 		movl	$72, 40(%rdx)
 1688      000000
 1689 00c6 488B17   		movq	(%rdi), %rdx
 1690 00c9 FF12     		call	*(%rdx)
 1691              	.LVL202:
 1692 00cb 488B4424 		movq	8(%rsp), %rax
 1692      08
 1693 00d0 E95CFFFF 		jmp	.L146
 1693      FF
 1694              		.cfi_endproc
 1695              	.LFE64:
 1697              		.section	.text.unlikely.alloc_sarray
 1698              	.LCOLDE9:
 1699              		.section	.text.alloc_sarray
 1700              	.LHOTE9:
 1701              		.section	.text.unlikely.realize_virt_arrays,"ax",@progbits
 1702              	.LCOLDB10:
 1703              		.section	.text.realize_virt_arrays,"ax",@progbits
 1704              	.LHOTB10:
 1705              		.p2align 4,,15
 1707              	realize_virt_arrays:
 1708              	.LFB68:
 586:fltk-1.3.4-1/jpeg/jmemmgr.c ****   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 1709              		.loc 1 586 0
 1710              		.cfi_startproc
 1711              	.LVL203:
 1712 0000 4156     		pushq	%r14
 1713              		.cfi_def_cfa_offset 16
 1714              		.cfi_offset 14, -16
 1715 0002 4155     		pushq	%r13
 1716              		.cfi_def_cfa_offset 24
 1717              		.cfi_offset 13, -24
 1718 0004 4154     		pushq	%r12
 1719              		.cfi_def_cfa_offset 32
 1720              		.cfi_offset 12, -32
 1721 0006 55       		pushq	%rbp
 1722              		.cfi_def_cfa_offset 40
 1723              		.cfi_offset 6, -40
 1724 0007 53       		pushq	%rbx
 1725              		.cfi_def_cfa_offset 48
 1726              		.cfi_offset 3, -48
 587:fltk-1.3.4-1/jpeg/jmemmgr.c ****   long space_per_minheight, maximum_space, avail_mem;
 1727              		.loc 1 587 0
 1728 0008 488B6F08 		movq	8(%rdi), %rbp
 1729              	.LVL204:
 599:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (sptr->mem_buffer == NULL) { /* if not realized yet */
 1730              		.loc 1 599 0
 1731 000c 488B8588 		movq	136(%rbp), %rax
 1731      000000
 1732              	.LVL205:
 1733 0013 4885C0   		testq	%rax, %rax
 1734 0016 0F843E02 		je	.L164
 1734      0000
 1735 001c 4531F6   		xorl	%r14d, %r14d
 1736 001f 31DB     		xorl	%ebx, %ebx
 1737 0021 EB0E     		jmp	.L166
 1738              	.LVL206:
 1739              		.p2align 4,,10
 1740 0023 0F1F4400 		.p2align 3
 1740      00
 1741              	.L165:
 599:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (sptr->mem_buffer == NULL) { /* if not realized yet */
 1742              		.loc 1 599 0 is_stmt 0 discriminator 2
 1743 0028 488B4030 		movq	48(%rax), %rax
 1744              	.LVL207:
 1745 002c 4885C0   		testq	%rax, %rax
 1746 002f 742F     		je	.L198
 1747              	.LVL208:
 1748              	.L166:
 600:fltk-1.3.4-1/jpeg/jmemmgr.c ****       space_per_minheight += (long) sptr->maxaccess *
 1749              		.loc 1 600 0 is_stmt 1
 1750 0031 48833800 		cmpq	$0, (%rax)
 1751 0035 75F1     		jne	.L165
 602:fltk-1.3.4-1/jpeg/jmemmgr.c ****       maximum_space += (long) sptr->rows_in_array *
 1752              		.loc 1 602 0
 1753 0037 8B500C   		movl	12(%rax), %edx
 601:fltk-1.3.4-1/jpeg/jmemmgr.c **** 			     (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
 1754              		.loc 1 601 0
 1755 003a 8B4810   		movl	16(%rax), %ecx
 1756 003d 480FAFCA 		imulq	%rdx, %rcx
 1757 0041 4801CB   		addq	%rcx, %rbx
 1758              	.LVL209:
 603:fltk-1.3.4-1/jpeg/jmemmgr.c **** 		       (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
 1759              		.loc 1 603 0
 1760 0044 8B4808   		movl	8(%rax), %ecx
 599:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (sptr->mem_buffer == NULL) { /* if not realized yet */
 1761              		.loc 1 599 0
 1762 0047 488B4030 		movq	48(%rax), %rax
 1763              	.LVL210:
 603:fltk-1.3.4-1/jpeg/jmemmgr.c **** 		       (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
 1764              		.loc 1 603 0
 1765 004b 480FAFD1 		imulq	%rcx, %rdx
 1766 004f 4901D6   		addq	%rdx, %r14
 1767              	.LVL211:
 599:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (sptr->mem_buffer == NULL) { /* if not realized yet */
 1768              		.loc 1 599 0
 1769 0052 4885C0   		testq	%rax, %rax
 1770 0055 75DA     		jne	.L166
 1771 0057 660F1F84 		.p2align 4,,10
 1771      00000000 
 1771      00
 1772              		.p2align 3
 1773              	.L198:
 607:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (bptr->mem_buffer == NULL) { /* if not realized yet */
 1774              		.loc 1 607 0
 1775 0060 488B8590 		movq	144(%rbp), %rax
 1775      000000
 1776              	.LVL212:
 1777 0067 4885C0   		testq	%rax, %rax
 1778 006a 750D     		jne	.L169
 1779 006c EB42     		jmp	.L167
 1780 006e 6690     		.p2align 4,,10
 1781              		.p2align 3
 1782              	.L168:
 607:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (bptr->mem_buffer == NULL) { /* if not realized yet */
 1783              		.loc 1 607 0 is_stmt 0 discriminator 2
 1784 0070 488B4030 		movq	48(%rax), %rax
 1785              	.LVL213:
 1786 0074 4885C0   		testq	%rax, %rax
 1787 0077 7437     		je	.L167
 1788              	.LVL214:
 1789              	.L169:
 608:fltk-1.3.4-1/jpeg/jmemmgr.c ****       space_per_minheight += (long) bptr->maxaccess *
 1790              		.loc 1 608 0 is_stmt 1
 1791 0079 48833800 		cmpq	$0, (%rax)
 1792 007d 75F1     		jne	.L168
 610:fltk-1.3.4-1/jpeg/jmemmgr.c ****       maximum_space += (long) bptr->rows_in_array *
 1793              		.loc 1 610 0
 1794 007f 8B500C   		movl	12(%rax), %edx
 609:fltk-1.3.4-1/jpeg/jmemmgr.c **** 			     (long) bptr->blocksperrow * SIZEOF(JBLOCK);
 1795              		.loc 1 609 0
 1796 0082 8B4810   		movl	16(%rax), %ecx
 1797 0085 480FAFCA 		imulq	%rdx, %rcx
 1798 0089 48C1E107 		salq	$7, %rcx
 1799 008d 4801CB   		addq	%rcx, %rbx
 1800              	.LVL215:
 611:fltk-1.3.4-1/jpeg/jmemmgr.c **** 		       (long) bptr->blocksperrow * SIZEOF(JBLOCK);
 1801              		.loc 1 611 0
 1802 0090 8B4808   		movl	8(%rax), %ecx
 607:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (bptr->mem_buffer == NULL) { /* if not realized yet */
 1803              		.loc 1 607 0
 1804 0093 488B4030 		movq	48(%rax), %rax
 1805              	.LVL216:
 611:fltk-1.3.4-1/jpeg/jmemmgr.c **** 		       (long) bptr->blocksperrow * SIZEOF(JBLOCK);
 1806              		.loc 1 611 0
 1807 0097 480FAFD1 		imulq	%rcx, %rdx
 1808 009b 48C1E207 		salq	$7, %rdx
 1809 009f 4901D6   		addq	%rdx, %r14
 1810              	.LVL217:
 607:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (bptr->mem_buffer == NULL) { /* if not realized yet */
 1811              		.loc 1 607 0
 1812 00a2 4885C0   		testq	%rax, %rax
 1813 00a5 75D2     		jne	.L169
 1814 00a7 660F1F84 		.p2align 4,,10
 1814      00000000 
 1814      00
 1815              		.p2align 3
 1816              	.L167:
 616:fltk-1.3.4-1/jpeg/jmemmgr.c ****     return;			/* no unrealized arrays, no work */
 1817              		.loc 1 616 0
 1818 00b0 4885DB   		testq	%rbx, %rbx
 1819 00b3 0F8E1D01 		jle	.L163
 1819      0000
 620:fltk-1.3.4-1/jpeg/jmemmgr.c **** 				 mem->total_space_allocated);
 1820              		.loc 1 620 0
 1821 00b9 488B8D98 		movq	152(%rbp), %rcx
 1821      000000
 1822 00c0 4C89F2   		movq	%r14, %rdx
 1823 00c3 4889DE   		movq	%rbx, %rsi
 1824 00c6 4989FC   		movq	%rdi, %r12
 628:fltk-1.3.4-1/jpeg/jmemmgr.c ****   else {
 1825              		.loc 1 628 0
 1826 00c9 41BD00CA 		movl	$1000000000, %r13d
 1826      9A3B
 620:fltk-1.3.4-1/jpeg/jmemmgr.c **** 				 mem->total_space_allocated);
 1827              		.loc 1 620 0
 1828 00cf E8000000 		call	jpeg_mem_available
 1828      00
 1829              	.LVL218:
 627:fltk-1.3.4-1/jpeg/jmemmgr.c ****     max_minheights = 1000000000L;
 1830              		.loc 1 627 0
 1831 00d4 4C39F0   		cmpq	%r14, %rax
 1832 00d7 0F8C0301 		jl	.L199
 1832      0000
 1833              	.LVL219:
 1834              	.L171:
 640:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (sptr->mem_buffer == NULL) { /* if not realized yet */
 1835              		.loc 1 640 0
 1836 00dd 488B9D88 		movq	136(%rbp), %rbx
 1836      000000
 1837              	.LVL220:
 1838 00e4 4885DB   		testq	%rbx, %rbx
 1839 00e7 7510     		jne	.L191
 1840 00e9 EB75     		jmp	.L179
 1841 00eb 0F1F4400 		.p2align 4,,10
 1841      00
 1842              		.p2align 3
 1843              	.L175:
 640:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (sptr->mem_buffer == NULL) { /* if not realized yet */
 1844              		.loc 1 640 0 is_stmt 0 discriminator 2
 1845 00f0 488B5B30 		movq	48(%rbx), %rbx
 1846              	.LVL221:
 1847 00f4 4885DB   		testq	%rbx, %rbx
 1848 00f7 7467     		je	.L179
 1849              	.L191:
 641:fltk-1.3.4-1/jpeg/jmemmgr.c ****       minheights = ((long) sptr->rows_in_array - 1L) / sptr->maxaccess + 1L;
 1850              		.loc 1 641 0 is_stmt 1
 1851 00f9 48833B00 		cmpq	$0, (%rbx)
 1852 00fd 75F1     		jne	.L175
 642:fltk-1.3.4-1/jpeg/jmemmgr.c ****       if (minheights <= max_minheights) {
 1853              		.loc 1 642 0
 1854 00ff 8B7B08   		movl	8(%rbx), %edi
 1855 0102 8B7310   		movl	16(%rbx), %esi
 643:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	/* This buffer fits in memory */
 1856              		.loc 1 643 0
 1857 0105 488D47FF 		leaq	-1(%rdi), %rax
 642:fltk-1.3.4-1/jpeg/jmemmgr.c ****       if (minheights <= max_minheights) {
 1858              		.loc 1 642 0
 1859 0109 4889F9   		movq	%rdi, %rcx
 1860 010c 4989F0   		movq	%rsi, %r8
 1861              	.LVL222:
 643:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	/* This buffer fits in memory */
 1862              		.loc 1 643 0
 1863 010f 4899     		cqto
 1864 0111 48F7FE   		idivq	%rsi
 1865 0114 4939C5   		cmpq	%rax, %r13
 1866 0117 0F8E1301 		jle	.L176
 1866      0000
 645:fltk-1.3.4-1/jpeg/jmemmgr.c ****       } else {
 1867              		.loc 1 645 0
 1868 011d 897B14   		movl	%edi, 20(%rbx)
 1869              	.LVL223:
 1870              	.L177:
 655:fltk-1.3.4-1/jpeg/jmemmgr.c **** 				      sptr->samplesperrow, sptr->rows_in_mem);
 1871              		.loc 1 655 0
 1872 0120 8B530C   		movl	12(%rbx), %edx
 1873 0123 BE010000 		movl	$1, %esi
 1873      00
 1874 0128 4C89E7   		movq	%r12, %rdi
 1875 012b E8000000 		call	alloc_sarray
 1875      00
 1876              	.LVL224:
 1877 0130 488903   		movq	%rax, (%rbx)
 657:fltk-1.3.4-1/jpeg/jmemmgr.c ****       sptr->cur_start_row = 0;
 1878              		.loc 1 657 0
 1879 0133 8B85A000 		movl	160(%rbp), %eax
 1879      0000
 658:fltk-1.3.4-1/jpeg/jmemmgr.c ****       sptr->first_undef_row = 0;
 1880              		.loc 1 658 0
 1881 0139 C7431C00 		movl	$0, 28(%rbx)
 1881      000000
 659:fltk-1.3.4-1/jpeg/jmemmgr.c ****       sptr->dirty = FALSE;
 1882              		.loc 1 659 0
 1883 0140 C7432000 		movl	$0, 32(%rbx)
 1883      000000
 660:fltk-1.3.4-1/jpeg/jmemmgr.c ****     }
 1884              		.loc 1 660 0
 1885 0147 C7432800 		movl	$0, 40(%rbx)
 1885      000000
 657:fltk-1.3.4-1/jpeg/jmemmgr.c ****       sptr->cur_start_row = 0;
 1886              		.loc 1 657 0
 1887 014e 894318   		movl	%eax, 24(%rbx)
 640:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (sptr->mem_buffer == NULL) { /* if not realized yet */
 1888              		.loc 1 640 0
 1889 0151 488B5B30 		movq	48(%rbx), %rbx
 1890              	.LVL225:
 1891 0155 4885DB   		testq	%rbx, %rbx
 1892 0158 759F     		jne	.L191
 1893 015a 660F1F44 		.p2align 4,,10
 1893      0000
 1894              		.p2align 3
 1895              	.L179:
 664:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (bptr->mem_buffer == NULL) { /* if not realized yet */
 1896              		.loc 1 664 0
 1897 0160 488B9D90 		movq	144(%rbp), %rbx
 1897      000000
 1898              	.LVL226:
 1899 0167 4885DB   		testq	%rbx, %rbx
 1900 016a 750D     		jne	.L190
 1901 016c EB68     		jmp	.L163
 1902 016e 6690     		.p2align 4,,10
 1903              		.p2align 3
 1904              	.L180:
 664:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (bptr->mem_buffer == NULL) { /* if not realized yet */
 1905              		.loc 1 664 0 is_stmt 0 discriminator 2
 1906 0170 488B5B30 		movq	48(%rbx), %rbx
 1907              	.LVL227:
 1908 0174 4885DB   		testq	%rbx, %rbx
 1909 0177 745D     		je	.L163
 1910              	.L190:
 665:fltk-1.3.4-1/jpeg/jmemmgr.c ****       minheights = ((long) bptr->rows_in_array - 1L) / bptr->maxaccess + 1L;
 1911              		.loc 1 665 0 is_stmt 1
 1912 0179 48833B00 		cmpq	$0, (%rbx)
 1913 017d 75F1     		jne	.L180
 666:fltk-1.3.4-1/jpeg/jmemmgr.c ****       if (minheights <= max_minheights) {
 1914              		.loc 1 666 0
 1915 017f 8B7308   		movl	8(%rbx), %esi
 1916 0182 8B7B10   		movl	16(%rbx), %edi
 667:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	/* This buffer fits in memory */
 1917              		.loc 1 667 0
 1918 0185 488D46FF 		leaq	-1(%rsi), %rax
 666:fltk-1.3.4-1/jpeg/jmemmgr.c ****       if (minheights <= max_minheights) {
 1919              		.loc 1 666 0
 1920 0189 4889F1   		movq	%rsi, %rcx
 1921 018c 4989F8   		movq	%rdi, %r8
 1922              	.LVL228:
 667:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	/* This buffer fits in memory */
 1923              		.loc 1 667 0
 1924 018f 4899     		cqto
 1925 0191 48F7FF   		idivq	%rdi
 1926 0194 4939C5   		cmpq	%rax, %r13
 1927 0197 7E67     		jle	.L181
 669:fltk-1.3.4-1/jpeg/jmemmgr.c ****       } else {
 1928              		.loc 1 669 0
 1929 0199 897314   		movl	%esi, 20(%rbx)
 1930              	.LVL229:
 1931              	.L182:
 679:fltk-1.3.4-1/jpeg/jmemmgr.c **** 				      bptr->blocksperrow, bptr->rows_in_mem);
 1932              		.loc 1 679 0
 1933 019c 8B530C   		movl	12(%rbx), %edx
 1934 019f BE010000 		movl	$1, %esi
 1934      00
 1935 01a4 4C89E7   		movq	%r12, %rdi
 1936 01a7 E8000000 		call	alloc_barray
 1936      00
 1937              	.LVL230:
 1938 01ac 488903   		movq	%rax, (%rbx)
 681:fltk-1.3.4-1/jpeg/jmemmgr.c ****       bptr->cur_start_row = 0;
 1939              		.loc 1 681 0
 1940 01af 8B85A000 		movl	160(%rbp), %eax
 1940      0000
 682:fltk-1.3.4-1/jpeg/jmemmgr.c ****       bptr->first_undef_row = 0;
 1941              		.loc 1 682 0
 1942 01b5 C7431C00 		movl	$0, 28(%rbx)
 1942      000000
 683:fltk-1.3.4-1/jpeg/jmemmgr.c ****       bptr->dirty = FALSE;
 1943              		.loc 1 683 0
 1944 01bc C7432000 		movl	$0, 32(%rbx)
 1944      000000
 684:fltk-1.3.4-1/jpeg/jmemmgr.c ****     }
 1945              		.loc 1 684 0
 1946 01c3 C7432800 		movl	$0, 40(%rbx)
 1946      000000
 681:fltk-1.3.4-1/jpeg/jmemmgr.c ****       bptr->cur_start_row = 0;
 1947              		.loc 1 681 0
 1948 01ca 894318   		movl	%eax, 24(%rbx)
 664:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (bptr->mem_buffer == NULL) { /* if not realized yet */
 1949              		.loc 1 664 0
 1950 01cd 488B5B30 		movq	48(%rbx), %rbx
 1951              	.LVL231:
 1952 01d1 4885DB   		testq	%rbx, %rbx
 1953 01d4 75A3     		jne	.L190
 1954              	.LVL232:
 1955              	.L163:
 687:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 1956              		.loc 1 687 0
 1957 01d6 5B       		popq	%rbx
 1958              		.cfi_remember_state
 1959              		.cfi_def_cfa_offset 40
 1960 01d7 5D       		popq	%rbp
 1961              		.cfi_def_cfa_offset 32
 1962              	.LVL233:
 1963 01d8 415C     		popq	%r12
 1964              		.cfi_def_cfa_offset 24
 1965 01da 415D     		popq	%r13
 1966              		.cfi_def_cfa_offset 16
 1967 01dc 415E     		popq	%r14
 1968              		.cfi_def_cfa_offset 8
 1969 01de C3       		ret
 1970              	.LVL234:
 1971 01df 90       		.p2align 4,,10
 1972              		.p2align 3
 1973              	.L199:
 1974              		.cfi_restore_state
 630:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* If there doesn't seem to be enough space, try to get the minimum
 1975              		.loc 1 630 0
 1976 01e0 4899     		cqto
 635:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
 1977              		.loc 1 635 0
 1978 01e2 41BD0100 		movl	$1, %r13d
 1978      0000
 630:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* If there doesn't seem to be enough space, try to get the minimum
 1979              		.loc 1 630 0
 1980 01e8 48F7FB   		idivq	%rbx
 1981              	.LVL235:
 635:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
 1982              		.loc 1 635 0
 1983 01eb 4885C0   		testq	%rax, %rax
 1984 01ee 4C0F4FE8 		cmovg	%rax, %r13
 1985 01f2 E9E6FEFF 		jmp	.L171
 1985      FF
 1986              	.LVL236:
 1987 01f7 660F1F84 		.p2align 4,,10
 1987      00000000 
 1987      00
 1988              		.p2align 3
 1989              	.L181:
 673:fltk-1.3.4-1/jpeg/jmemmgr.c **** 				(long) bptr->rows_in_array *
 1990              		.loc 1 673 0
 1991 0200 8B530C   		movl	12(%rbx), %edx
 1992 0203 4C89E7   		movq	%r12, %rdi
 1993              	.LVL237:
 672:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	jpeg_open_backing_store(cinfo, & bptr->b_s_info,
 1994              		.loc 1 672 0
 1995 0206 450FAFC5 		imull	%r13d, %r8d
 1996              	.LVL238:
 673:fltk-1.3.4-1/jpeg/jmemmgr.c **** 				(long) bptr->rows_in_array *
 1997              		.loc 1 673 0
 1998 020a 480FAFD6 		imulq	%rsi, %rdx
 1999 020e 488D7338 		leaq	56(%rbx), %rsi
 672:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	jpeg_open_backing_store(cinfo, & bptr->b_s_info,
 2000              		.loc 1 672 0
 2001 0212 44894314 		movl	%r8d, 20(%rbx)
 673:fltk-1.3.4-1/jpeg/jmemmgr.c **** 				(long) bptr->rows_in_array *
 2002              		.loc 1 673 0
 2003 0216 48C1E207 		salq	$7, %rdx
 2004 021a E8000000 		call	jpeg_open_backing_store
 2004      00
 2005              	.LVL239:
 677:fltk-1.3.4-1/jpeg/jmemmgr.c ****       }
 2006              		.loc 1 677 0
 2007 021f C7432C01 		movl	$1, 44(%rbx)
 2007      000000
 2008 0226 8B4B14   		movl	20(%rbx), %ecx
 2009 0229 E96EFFFF 		jmp	.L182
 2009      FF
 2010              	.LVL240:
 2011 022e 6690     		.p2align 4,,10
 2012              		.p2align 3
 2013              	.L176:
 649:fltk-1.3.4-1/jpeg/jmemmgr.c **** 				(long) sptr->rows_in_array *
 2014              		.loc 1 649 0
 2015 0230 8B530C   		movl	12(%rbx), %edx
 2016 0233 488D7338 		leaq	56(%rbx), %rsi
 2017              	.LVL241:
 648:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	jpeg_open_backing_store(cinfo, & sptr->b_s_info,
 2018              		.loc 1 648 0
 2019 0237 450FAFC5 		imull	%r13d, %r8d
 2020              	.LVL242:
 649:fltk-1.3.4-1/jpeg/jmemmgr.c **** 				(long) sptr->rows_in_array *
 2021              		.loc 1 649 0
 2022 023b 480FAFD7 		imulq	%rdi, %rdx
 648:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	jpeg_open_backing_store(cinfo, & sptr->b_s_info,
 2023              		.loc 1 648 0
 2024 023f 44894314 		movl	%r8d, 20(%rbx)
 649:fltk-1.3.4-1/jpeg/jmemmgr.c **** 				(long) sptr->rows_in_array *
 2025              		.loc 1 649 0
 2026 0243 4C89E7   		movq	%r12, %rdi
 2027 0246 E8000000 		call	jpeg_open_backing_store
 2027      00
 2028              	.LVL243:
 653:fltk-1.3.4-1/jpeg/jmemmgr.c ****       }
 2029              		.loc 1 653 0
 2030 024b C7432C01 		movl	$1, 44(%rbx)
 2030      000000
 2031 0252 8B4B14   		movl	20(%rbx), %ecx
 2032 0255 E9C6FEFF 		jmp	.L177
 2032      FF
 2033              	.LVL244:
 2034              	.L164:
 607:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (bptr->mem_buffer == NULL) { /* if not realized yet */
 2035              		.loc 1 607 0
 2036 025a 488B8590 		movq	144(%rbp), %rax
 2036      000000
 2037              	.LVL245:
 598:fltk-1.3.4-1/jpeg/jmemmgr.c ****   for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
 2038              		.loc 1 598 0
 2039 0261 4531F6   		xorl	%r14d, %r14d
 597:fltk-1.3.4-1/jpeg/jmemmgr.c ****   maximum_space = 0;
 2040              		.loc 1 597 0
 2041 0264 31DB     		xorl	%ebx, %ebx
 607:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (bptr->mem_buffer == NULL) { /* if not realized yet */
 2042              		.loc 1 607 0
 2043 0266 4885C0   		testq	%rax, %rax
 2044 0269 0F850AFE 		jne	.L169
 2044      FFFF
 2045 026f E962FFFF 		jmp	.L163
 2045      FF
 2046              		.cfi_endproc
 2047              	.LFE68:
 2049              		.section	.text.unlikely.realize_virt_arrays
 2050              	.LCOLDE10:
 2051              		.section	.text.realize_virt_arrays
 2052              	.LHOTE10:
 2053              		.section	.text.unlikely.access_virt_sarray,"ax",@progbits
 2054              	.LCOLDB11:
 2055              		.section	.text.access_virt_sarray,"ax",@progbits
 2056              	.LHOTB11:
 2057              		.p2align 4,,15
 2059              	access_virt_sarray:
 2060              	.LFB71:
 763:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JDIMENSION end_row = start_row + num_rows;
 2061              		.loc 1 763 0
 2062              		.cfi_startproc
 2063              	.LVL246:
 2064 0000 4157     		pushq	%r15
 2065              		.cfi_def_cfa_offset 16
 2066              		.cfi_offset 15, -16
 2067 0002 4156     		pushq	%r14
 2068              		.cfi_def_cfa_offset 24
 2069              		.cfi_offset 14, -24
 2070 0004 89D0     		movl	%edx, %eax
 2071 0006 4155     		pushq	%r13
 2072              		.cfi_def_cfa_offset 32
 2073              		.cfi_offset 13, -32
 2074 0008 4154     		pushq	%r12
 2075              		.cfi_def_cfa_offset 40
 2076              		.cfi_offset 12, -40
 764:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JDIMENSION undef_row;
 2077              		.loc 1 764 0
 2078 000a 01C8     		addl	%ecx, %eax
 763:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JDIMENSION end_row = start_row + num_rows;
 2079              		.loc 1 763 0
 2080 000c 55       		pushq	%rbp
 2081              		.cfi_def_cfa_offset 48
 2082              		.cfi_offset 6, -48
 2083 000d 53       		pushq	%rbx
 2084              		.cfi_def_cfa_offset 56
 2085              		.cfi_offset 3, -56
 2086 000e 4989F6   		movq	%rsi, %r14
 2087 0011 4889FB   		movq	%rdi, %rbx
 2088 0014 4883EC28 		subq	$40, %rsp
 2089              		.cfi_def_cfa_offset 96
 768:fltk-1.3.4-1/jpeg/jmemmgr.c ****       ptr->mem_buffer == NULL)
 2090              		.loc 1 768 0
 2091 0018 3B4608   		cmpl	8(%rsi), %eax
 763:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JDIMENSION end_row = start_row + num_rows;
 2092              		.loc 1 763 0
 2093 001b 89542414 		movl	%edx, 20(%rsp)
 2094 001f 44894424 		movl	%r8d, 28(%rsp)
 2094      1C
 764:fltk-1.3.4-1/jpeg/jmemmgr.c ****   JDIMENSION undef_row;
 2095              		.loc 1 764 0
 2096 0024 89442418 		movl	%eax, 24(%rsp)
 2097              	.LVL247:
 768:fltk-1.3.4-1/jpeg/jmemmgr.c ****       ptr->mem_buffer == NULL)
 2098              		.loc 1 768 0
 2099 0028 7709     		ja	.L201
 768:fltk-1.3.4-1/jpeg/jmemmgr.c ****       ptr->mem_buffer == NULL)
 2100              		.loc 1 768 0 is_stmt 0 discriminator 1
 2101 002a 3B4E10   		cmpl	16(%rsi), %ecx
 2102 002d 0F86DD01 		jbe	.L245
 2102      0000
 2103              	.L201:
 770:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 2104              		.loc 1 770 0 is_stmt 1
 2105 0033 488B03   		movq	(%rbx), %rax
 2106              	.LVL248:
 2107 0036 4889DF   		movq	%rbx, %rdi
 2108              	.LVL249:
 2109 0039 C7402817 		movl	$23, 40(%rax)
 2109      000000
 2110 0040 488B03   		movq	(%rbx), %rax
 2111 0043 FF10     		call	*(%rax)
 2112              	.LVL250:
 2113              	.L202:
 773:fltk-1.3.4-1/jpeg/jmemmgr.c ****       end_row > ptr->cur_start_row+ptr->rows_in_mem) {
 2114              		.loc 1 773 0
 2115 0045 418B761C 		movl	28(%r14), %esi
 2116 0049 39742414 		cmpl	%esi, 20(%rsp)
 2117 004d 7210     		jb	.L203
 773:fltk-1.3.4-1/jpeg/jmemmgr.c ****       end_row > ptr->cur_start_row+ptr->rows_in_mem) {
 2118              		.loc 1 773 0 is_stmt 0 discriminator 1
 2119 004f 418B4614 		movl	20(%r14), %eax
 2120 0053 01F0     		addl	%esi, %eax
 2121 0055 39442418 		cmpl	%eax, 24(%rsp)
 2122 0059 0F860101 		jbe	.L243
 2122      0000
 2123              	.L203:
 775:fltk-1.3.4-1/jpeg/jmemmgr.c ****       ERREXIT(cinfo, JERR_VIRTUAL_BUG);
 2124              		.loc 1 775 0 is_stmt 1
 2125 005f 458B4E2C 		movl	44(%r14), %r9d
 2126 0063 4585C9   		testl	%r9d, %r9d
 2127 0066 0F84D402 		je	.L246
 2127      0000
 2128              	.L205:
 778:fltk-1.3.4-1/jpeg/jmemmgr.c ****       do_sarray_io(cinfo, ptr, TRUE);
 2129              		.loc 1 778 0
 2130 006c 458B4628 		movl	40(%r14), %r8d
 2131 0070 4585C0   		testl	%r8d, %r8d
 2132 0073 0F85D701 		jne	.L206
 2132      0000
 2133 0079 418B5614 		movl	20(%r14), %edx
 2134 007d 418B6E0C 		movl	12(%r14), %ebp
 2135 0081 418B4E20 		movl	32(%r14), %ecx
 2136              	.L207:
 789:fltk-1.3.4-1/jpeg/jmemmgr.c ****       ptr->cur_start_row = start_row;
 2137              		.loc 1 789 0
 2138 0085 8B442414 		movl	20(%rsp), %eax
 2139 0089 39F0     		cmpl	%esi, %eax
 2140 008b 0F876F01 		ja	.L247
 2140      0000
 2141              	.LBB43:
 795:fltk-1.3.4-1/jpeg/jmemmgr.c ****       if (ltemp < 0)
 2142              		.loc 1 795 0
 2143 0091 8B442418 		movl	24(%rsp), %eax
 2144              	.LVL251:
 798:fltk-1.3.4-1/jpeg/jmemmgr.c ****     }
 2145              		.loc 1 798 0
 2146 0095 BE000000 		movl	$0, %esi
 2146      00
 2147 009a 4829D0   		subq	%rdx, %rax
 2148              	.LVL252:
 2149 009d 480F48C6 		cmovs	%rsi, %rax
 2150 00a1 89C6     		movl	%eax, %esi
 2151 00a3 4189461C 		movl	%eax, 28(%r14)
 2152              	.LVL253:
 2153              	.L213:
 2154              	.LBE43:
 2155              	.LBB44:
 2156              	.LBB45:
 697:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Loop to read or write each allocation chunk in mem_buffer */
 2157              		.loc 1 697 0
 2158 00a7 4989F4   		movq	%rsi, %r12
 2159 00aa 4C0FAFE5 		imulq	%rbp, %r12
 2160              	.LVL254:
 699:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* One chunk, but check for short chunk at end of buffer */
 2161              		.loc 1 699 0
 2162 00ae 4885D2   		testq	%rdx, %rdx
 2163 00b1 0F84AD00 		je	.L204
 2163      0000
 701:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Transfer no more than is currently defined */
 2164              		.loc 1 701 0
 2165 00b7 458B4618 		movl	24(%r14), %r8d
 2166 00bb 4939D0   		cmpq	%rdx, %r8
 2167 00be 4C0F4FC2 		cmovg	%rdx, %r8
 2168              	.LVL255:
 704:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Transfer no more than fits in file */
 2169              		.loc 1 704 0
 2170 00c2 89CA     		movl	%ecx, %edx
 2171 00c4 4889D0   		movq	%rdx, %rax
 2172 00c7 4C89C2   		movq	%r8, %rdx
 2173 00ca 4829F0   		subq	%rsi, %rax
 2174 00cd 4C39C0   		cmpq	%r8, %rax
 706:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (rows <= 0)		/* this chunk might be past end of file! */
 2175              		.loc 1 706 0
 2176 00d0 458B4608 		movl	8(%r14), %r8d
 2177              	.LVL256:
 704:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Transfer no more than fits in file */
 2178              		.loc 1 704 0
 2179 00d4 480F4ED0 		cmovle	%rax, %rdx
 2180              	.LVL257:
 706:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (rows <= 0)		/* this chunk might be past end of file! */
 2181              		.loc 1 706 0
 2182 00d8 4929F0   		subq	%rsi, %r8
 2183 00db 4939D0   		cmpq	%rdx, %r8
 2184 00de 4C0F4FC2 		cmovg	%rdx, %r8
 2185              	.LVL258:
 707:fltk-1.3.4-1/jpeg/jmemmgr.c ****       break;
 2186              		.loc 1 707 0
 2187 00e2 4D85C0   		testq	%r8, %r8
 2188 00e5 7E7D     		jle	.L204
 2189 00e7 498D4638 		leaq	56(%r14), %rax
 2190 00eb 4531ED   		xorl	%r13d, %r13d
 2191 00ee 48894424 		movq	%rax, 8(%rsp)
 2191      08
 2192 00f3 EB38     		jmp	.L214
 2193              	.LVL259:
 2194              		.p2align 4,,10
 2195 00f5 0F1F00   		.p2align 3
 2196              	.L215:
 701:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Transfer no more than is currently defined */
 2197              		.loc 1 701 0
 2198 00f8 4D29E8   		subq	%r13, %r8
 703:fltk-1.3.4-1/jpeg/jmemmgr.c ****     rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
 2199              		.loc 1 703 0
 2200 00fb 418B761C 		movl	28(%r14), %esi
 701:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Transfer no more than is currently defined */
 2201              		.loc 1 701 0
 2202 00ff 4939D0   		cmpq	%rdx, %r8
 2203 0102 490F4ED0 		cmovle	%r8, %rdx
 2204              	.LVL260:
 704:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Transfer no more than fits in file */
 2205              		.loc 1 704 0
 2206 0106 458B4620 		movl	32(%r14), %r8d
 703:fltk-1.3.4-1/jpeg/jmemmgr.c ****     rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
 2207              		.loc 1 703 0
 2208 010a 4C01EE   		addq	%r13, %rsi
 2209              	.LVL261:
 704:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Transfer no more than fits in file */
 2210              		.loc 1 704 0
 2211 010d 4C89C1   		movq	%r8, %rcx
 2212 0110 4929F0   		subq	%rsi, %r8
 2213 0113 4939D0   		cmpq	%rdx, %r8
 2214 0116 490F4ED0 		cmovle	%r8, %rdx
 2215              	.LVL262:
 706:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (rows <= 0)		/* this chunk might be past end of file! */
 2216              		.loc 1 706 0
 2217 011a 458B4608 		movl	8(%r14), %r8d
 2218 011e 4929F0   		subq	%rsi, %r8
 2219 0121 4939D0   		cmpq	%rdx, %r8
 2220 0124 4C0F4FC2 		cmovg	%rdx, %r8
 2221              	.LVL263:
 707:fltk-1.3.4-1/jpeg/jmemmgr.c ****       break;
 2222              		.loc 1 707 0
 2223 0128 4D85C0   		testq	%r8, %r8
 2224 012b 7E37     		jle	.L204
 2225              	.LVL264:
 2226              	.L214:
 709:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (writing)
 2227              		.loc 1 709 0
 2228 012d 4D89C7   		movq	%r8, %r15
 715:fltk-1.3.4-1/jpeg/jmemmgr.c **** 					   (void FAR *) ptr->mem_buffer[i],
 2229              		.loc 1 715 0
 2230 0130 498B16   		movq	(%r14), %rdx
 2231 0133 4C89E1   		movq	%r12, %rcx
 709:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (writing)
 2232              		.loc 1 709 0
 2233 0136 4C0FAFFD 		imulq	%rbp, %r15
 2234              	.LVL265:
 715:fltk-1.3.4-1/jpeg/jmemmgr.c **** 					   (void FAR *) ptr->mem_buffer[i],
 2235              		.loc 1 715 0
 2236 013a 488B7424 		movq	8(%rsp), %rsi
 2236      08
 2237 013f 4889DF   		movq	%rbx, %rdi
 2238 0142 4A8B14EA 		movq	(%rdx,%r13,8), %rdx
 2239 0146 4D89F8   		movq	%r15, %r8
 2240              	.LVL266:
 718:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
 2241              		.loc 1 718 0
 2242 0149 4D01FC   		addq	%r15, %r12
 2243              	.LVL267:
 715:fltk-1.3.4-1/jpeg/jmemmgr.c **** 					   (void FAR *) ptr->mem_buffer[i],
 2244              		.loc 1 715 0
 2245 014c 41FF5638 		call	*56(%r14)
 2246              	.LVL268:
 699:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* One chunk, but check for short chunk at end of buffer */
 2247              		.loc 1 699 0
 2248 0150 418B5618 		movl	24(%r14), %edx
 2249 0154 458B4614 		movl	20(%r14), %r8d
 2250 0158 4901D5   		addq	%rdx, %r13
 2251              	.LVL269:
 2252 015b 4D39E8   		cmpq	%r13, %r8
 2253 015e 7F98     		jg	.L215
 2254              	.LVL270:
 2255              	.L243:
 2256 0160 418B4E20 		movl	32(%r14), %ecx
 2257              	.L204:
 2258              	.LBE45:
 2259              	.LBE44:
 810:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (ptr->first_undef_row < start_row) {
 2260              		.loc 1 810 0
 2261 0164 394C2418 		cmpl	%ecx, 24(%rsp)
 2262 0168 7661     		jbe	.L216
 811:fltk-1.3.4-1/jpeg/jmemmgr.c ****       if (writable)		/* writer skipped over a section of array */
 2263              		.loc 1 811 0
 2264 016a 8B442414 		movl	20(%rsp), %eax
 2265 016e 39C8     		cmpl	%ecx, %eax
 2266 0170 0F86AA00 		jbe	.L217
 2266      0000
 812:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 2267              		.loc 1 812 0
 2268 0176 8B7C241C 		movl	28(%rsp), %edi
 2269 017a 89C1     		movl	%eax, %ecx
 2270 017c 85FF     		testl	%edi, %edi
 2271 017e 0F85D701 		jne	.L248
 2271      0000
 2272              	.L218:
 820:fltk-1.3.4-1/jpeg/jmemmgr.c ****       size_t bytesperrow = (size_t) ptr->samplesperrow * SIZEOF(JSAMPLE);
 2273              		.loc 1 820 0
 2274 0184 418B5624 		movl	36(%r14), %edx
 2275 0188 85D2     		testl	%edx, %edx
 2276 018a 0F84E601 		je	.L249
 2276      0000
 2277              	.L224:
 2278              	.LBB46:
 822:fltk-1.3.4-1/jpeg/jmemmgr.c ****       end_row -= ptr->cur_start_row;
 2279              		.loc 1 822 0
 2280 0190 418B461C 		movl	28(%r14), %eax
 823:fltk-1.3.4-1/jpeg/jmemmgr.c ****       while (undef_row < end_row) {
 2281              		.loc 1 823 0
 2282 0194 448B6C24 		movl	24(%rsp), %r13d
 2282      18
 822:fltk-1.3.4-1/jpeg/jmemmgr.c ****       end_row -= ptr->cur_start_row;
 2283              		.loc 1 822 0
 2284 0199 89CB     		movl	%ecx, %ebx
 2285              	.LVL271:
 821:fltk-1.3.4-1/jpeg/jmemmgr.c ****       undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
 2286              		.loc 1 821 0
 2287 019b 418B6E0C 		movl	12(%r14), %ebp
 2288              	.LVL272:
 822:fltk-1.3.4-1/jpeg/jmemmgr.c ****       end_row -= ptr->cur_start_row;
 2289              		.loc 1 822 0
 2290 019f 29C3     		subl	%eax, %ebx
 2291              	.LVL273:
 823:fltk-1.3.4-1/jpeg/jmemmgr.c ****       while (undef_row < end_row) {
 2292              		.loc 1 823 0
 2293 01a1 4129C5   		subl	%eax, %r13d
 2294              	.LVL274:
 824:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	FMEMZERO((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
 2295              		.loc 1 824 0
 2296 01a4 4439EB   		cmpl	%r13d, %ebx
 2297 01a7 7326     		jnb	.L220
 2298 01a9 0F1F8000 		.p2align 4,,10
 2298      000000
 2299              		.p2align 3
 2300              	.L221:
 2301              	.LVL275:
 825:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	undef_row++;
 2302              		.loc 1 825 0
 2303 01b0 498B06   		movq	(%r14), %rax
 2304 01b3 89DA     		movl	%ebx, %edx
 2305              	.LBB47:
 2306              	.LBB48:
 2307              		.loc 2 90 0
 2308 01b5 31F6     		xorl	%esi, %esi
 2309              	.LBE48:
 2310              	.LBE47:
 826:fltk-1.3.4-1/jpeg/jmemmgr.c ****       }
 2311              		.loc 1 826 0
 2312 01b7 83C301   		addl	$1, %ebx
 2313              	.LVL276:
 2314              	.LBB50:
 2315              	.LBB49:
 2316              		.loc 2 90 0
 2317 01ba 488B3CD0 		movq	(%rax,%rdx,8), %rdi
 2318 01be 4889EA   		movq	%rbp, %rdx
 2319 01c1 E8000000 		call	memset
 2319      00
 2320              	.LVL277:
 2321              	.LBE49:
 2322              	.LBE50:
 824:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	FMEMZERO((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
 2323              		.loc 1 824 0
 2324 01c6 4139DD   		cmpl	%ebx, %r13d
 2325 01c9 77E5     		ja	.L221
 2326              	.LVL278:
 2327              	.L216:
 2328 01cb 418B461C 		movl	28(%r14), %eax
 2329              	.L220:
 2330              	.LBE46:
 834:fltk-1.3.4-1/jpeg/jmemmgr.c ****     ptr->dirty = TRUE;
 2331              		.loc 1 834 0
 2332 01cf 8B4C241C 		movl	28(%rsp), %ecx
 2333 01d3 85C9     		testl	%ecx, %ecx
 2334 01d5 7408     		je	.L223
 2335              	.L222:
 835:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Return address of proper part of the buffer */
 2336              		.loc 1 835 0
 2337 01d7 41C74628 		movl	$1, 40(%r14)
 2337      01000000 
 2338              	.L223:
 837:fltk-1.3.4-1/jpeg/jmemmgr.c **** }
 2339              		.loc 1 837 0
 2340 01df 448B6424 		movl	20(%rsp), %r12d
 2340      14
 2341 01e4 4129C4   		subl	%eax, %r12d
 2342 01e7 498B06   		movq	(%r14), %rax
 838:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 2343              		.loc 1 838 0
 2344 01ea 4883C428 		addq	$40, %rsp
 2345              		.cfi_remember_state
 2346              		.cfi_def_cfa_offset 56
 2347 01ee 5B       		popq	%rbx
 2348              		.cfi_def_cfa_offset 48
 2349 01ef 5D       		popq	%rbp
 2350              		.cfi_def_cfa_offset 40
 837:fltk-1.3.4-1/jpeg/jmemmgr.c **** }
 2351              		.loc 1 837 0
 2352 01f0 4A8D04E0 		leaq	(%rax,%r12,8), %rax
 838:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 2353              		.loc 1 838 0
 2354 01f4 415C     		popq	%r12
 2355              		.cfi_def_cfa_offset 32
 2356 01f6 415D     		popq	%r13
 2357              		.cfi_def_cfa_offset 24
 2358 01f8 415E     		popq	%r14
 2359              		.cfi_def_cfa_offset 16
 2360              	.LVL279:
 2361 01fa 415F     		popq	%r15
 2362              		.cfi_def_cfa_offset 8
 2363 01fc C3       		ret
 2364              	.LVL280:
 2365 01fd 0F1F00   		.p2align 4,,10
 2366              		.p2align 3
 2367              	.L247:
 2368              		.cfi_restore_state
 790:fltk-1.3.4-1/jpeg/jmemmgr.c ****     } else {
 2369              		.loc 1 790 0
 2370 0200 4189461C 		movl	%eax, 28(%r14)
 2371 0204 89C6     		movl	%eax, %esi
 2372 0206 E99CFEFF 		jmp	.L213
 2372      FF
 2373              	.LVL281:
 2374 020b 0F1F4400 		.p2align 4,,10
 2374      00
 2375              		.p2align 3
 2376              	.L245:
 768:fltk-1.3.4-1/jpeg/jmemmgr.c ****       ptr->mem_buffer == NULL)
 2377              		.loc 1 768 0 discriminator 2
 2378 0210 48833E00 		cmpq	$0, (%rsi)
 2379 0214 0F852BFE 		jne	.L202
 2379      FFFF
 2380 021a E914FEFF 		jmp	.L201
 2380      FF
 2381              	.LVL282:
 2382 021f 90       		.p2align 4,,10
 2383              		.p2align 3
 2384              	.L217:
 818:fltk-1.3.4-1/jpeg/jmemmgr.c ****       ptr->first_undef_row = end_row;
 2385              		.loc 1 818 0
 2386 0220 8B74241C 		movl	28(%rsp), %esi
 2387 0224 85F6     		testl	%esi, %esi
 2388 0226 0F8458FF 		je	.L218
 2388      FFFF
 2389              	.LVL283:
 2390              	.L219:
 819:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (ptr->pre_zero) {
 2391              		.loc 1 819 0
 2392 022c 8B442418 		movl	24(%rsp), %eax
 2393 0230 41894620 		movl	%eax, 32(%r14)
 820:fltk-1.3.4-1/jpeg/jmemmgr.c ****       size_t bytesperrow = (size_t) ptr->samplesperrow * SIZEOF(JSAMPLE);
 2394              		.loc 1 820 0
 2395 0234 418B4624 		movl	36(%r14), %eax
 2396 0238 85C0     		testl	%eax, %eax
 2397 023a 0F8550FF 		jne	.L224
 2397      FFFF
 2398 0240 418B461C 		movl	28(%r14), %eax
 2399 0244 EB91     		jmp	.L222
 2400              	.LVL284:
 2401 0246 662E0F1F 		.p2align 4,,10
 2401      84000000 
 2401      0000
 2402              		.p2align 3
 2403              	.L206:
 2404              	.LBB51:
 2405              	.LBB52:
 696:fltk-1.3.4-1/jpeg/jmemmgr.c ****   file_offset = ptr->cur_start_row * bytesperrow;
 2406              		.loc 1 696 0
 2407 0250 418B6E0C 		movl	12(%r14), %ebp
 2408              	.LVL285:
 699:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* One chunk, but check for short chunk at end of buffer */
 2409              		.loc 1 699 0
 2410 0254 418B5614 		movl	20(%r14), %edx
 697:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Loop to read or write each allocation chunk in mem_buffer */
 2411              		.loc 1 697 0
 2412 0258 89F7     		movl	%esi, %edi
 2413 025a 4989ED   		movq	%rbp, %r13
 2414 025d 4C0FAFEF 		imulq	%rdi, %r13
 2415              	.LVL286:
 699:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* One chunk, but check for short chunk at end of buffer */
 2416              		.loc 1 699 0
 2417 0261 4885D2   		testq	%rdx, %rdx
 2418 0264 0F84C000 		je	.L242
 2418      0000
 701:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Transfer no more than is currently defined */
 2419              		.loc 1 701 0
 2420 026a 458B4618 		movl	24(%r14), %r8d
 704:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Transfer no more than fits in file */
 2421              		.loc 1 704 0
 2422 026e 418B4620 		movl	32(%r14), %eax
 701:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Transfer no more than is currently defined */
 2423              		.loc 1 701 0
 2424 0272 4939D0   		cmpq	%rdx, %r8
 704:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Transfer no more than fits in file */
 2425              		.loc 1 704 0
 2426 0275 4889C1   		movq	%rax, %rcx
 701:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Transfer no more than is currently defined */
 2427              		.loc 1 701 0
 2428 0278 4C0F4FC2 		cmovg	%rdx, %r8
 2429              	.LVL287:
 704:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Transfer no more than fits in file */
 2430              		.loc 1 704 0
 2431 027c 4829F8   		subq	%rdi, %rax
 2432 027f 4C39C0   		cmpq	%r8, %rax
 2433 0282 490F4FC0 		cmovg	%r8, %rax
 2434              	.LVL288:
 706:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (rows <= 0)		/* this chunk might be past end of file! */
 2435              		.loc 1 706 0
 2436 0286 458B4608 		movl	8(%r14), %r8d
 2437 028a 4929F8   		subq	%rdi, %r8
 2438 028d 4939C0   		cmpq	%rax, %r8
 2439 0290 4C0F4FC0 		cmovg	%rax, %r8
 2440              	.LVL289:
 707:fltk-1.3.4-1/jpeg/jmemmgr.c ****       break;
 2441              		.loc 1 707 0
 2442 0294 4D85C0   		testq	%r8, %r8
 2443 0297 0F8E9100 		jle	.L209
 2443      0000
 2444 029d 498D4638 		leaq	56(%r14), %rax
 2445 02a1 4531E4   		xorl	%r12d, %r12d
 2446 02a4 48894424 		movq	%rax, 8(%rsp)
 2446      08
 2447 02a9 EB44     		jmp	.L210
 2448              	.LVL290:
 2449 02ab 0F1F4400 		.p2align 4,,10
 2449      00
 2450              		.p2align 3
 2451              	.L211:
 703:fltk-1.3.4-1/jpeg/jmemmgr.c ****     rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
 2452              		.loc 1 703 0
 2453 02b0 458B5E1C 		movl	28(%r14), %r11d
 704:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Transfer no more than fits in file */
 2454              		.loc 1 704 0
 2455 02b4 458B4620 		movl	32(%r14), %r8d
 701:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Transfer no more than is currently defined */
 2456              		.loc 1 701 0
 2457 02b8 4889D7   		movq	%rdx, %rdi
 2458 02bb 4C29E7   		subq	%r12, %rdi
 2459 02be 4839CF   		cmpq	%rcx, %rdi
 2460 02c1 480F4FF9 		cmovg	%rcx, %rdi
 2461              	.LVL291:
 703:fltk-1.3.4-1/jpeg/jmemmgr.c ****     rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
 2462              		.loc 1 703 0
 2463 02c5 4C89DE   		movq	%r11, %rsi
 2464 02c8 4D01E3   		addq	%r12, %r11
 2465              	.LVL292:
 704:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Transfer no more than fits in file */
 2466              		.loc 1 704 0
 2467 02cb 4C89C1   		movq	%r8, %rcx
 2468 02ce 4D29D8   		subq	%r11, %r8
 2469 02d1 4939F8   		cmpq	%rdi, %r8
 2470 02d4 490F4EF8 		cmovle	%r8, %rdi
 2471              	.LVL293:
 706:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (rows <= 0)		/* this chunk might be past end of file! */
 2472              		.loc 1 706 0
 2473 02d8 458B4608 		movl	8(%r14), %r8d
 2474 02dc 4D29D8   		subq	%r11, %r8
 2475 02df 4939F8   		cmpq	%rdi, %r8
 2476 02e2 4C0F4FC7 		cmovg	%rdi, %r8
 2477              	.LVL294:
 707:fltk-1.3.4-1/jpeg/jmemmgr.c ****       break;
 2478              		.loc 1 707 0
 2479 02e6 4D85C0   		testq	%r8, %r8
 2480 02e9 0F8EA900 		jle	.L250
 2480      0000
 2481              	.LVL295:
 2482              	.L210:
 709:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (writing)
 2483              		.loc 1 709 0
 2484 02ef 4D89C7   		movq	%r8, %r15
 711:fltk-1.3.4-1/jpeg/jmemmgr.c **** 					    (void FAR *) ptr->mem_buffer[i],
 2485              		.loc 1 711 0
 2486 02f2 498B16   		movq	(%r14), %rdx
 2487 02f5 4C89E9   		movq	%r13, %rcx
 709:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if (writing)
 2488              		.loc 1 709 0
 2489 02f8 4C0FAFFD 		imulq	%rbp, %r15
 2490              	.LVL296:
 711:fltk-1.3.4-1/jpeg/jmemmgr.c **** 					    (void FAR *) ptr->mem_buffer[i],
 2491              		.loc 1 711 0
 2492 02fc 488B7424 		movq	8(%rsp), %rsi
 2492      08
 2493 0301 4889DF   		movq	%rbx, %rdi
 2494 0304 4A8B14E2 		movq	(%rdx,%r12,8), %rdx
 2495 0308 4D89F8   		movq	%r15, %r8
 2496              	.LVL297:
 718:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
 2497              		.loc 1 718 0
 2498 030b 4D01FD   		addq	%r15, %r13
 2499              	.LVL298:
 711:fltk-1.3.4-1/jpeg/jmemmgr.c **** 					    (void FAR *) ptr->mem_buffer[i],
 2500              		.loc 1 711 0
 2501 030e 41FF5640 		call	*64(%r14)
 2502              	.LVL299:
 699:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* One chunk, but check for short chunk at end of buffer */
 2503              		.loc 1 699 0
 2504 0312 418B4E18 		movl	24(%r14), %ecx
 2505 0316 418B5614 		movl	20(%r14), %edx
 2506 031a 4901CC   		addq	%rcx, %r12
 2507              	.LVL300:
 2508 031d 4C39E2   		cmpq	%r12, %rdx
 2509 0320 7F8E     		jg	.L211
 2510 0322 418B6E0C 		movl	12(%r14), %ebp
 2511              	.LVL301:
 2512 0326 418B761C 		movl	28(%r14), %esi
 2513              	.LVL302:
 2514              	.L242:
 2515 032a 418B4E20 		movl	32(%r14), %ecx
 2516              	.L209:
 2517              	.LVL303:
 2518              	.LBE52:
 2519              	.LBE51:
 780:fltk-1.3.4-1/jpeg/jmemmgr.c ****     }
 2520              		.loc 1 780 0
 2521 032e 41C74628 		movl	$0, 40(%r14)
 2521      00000000 
 2522 0336 E94AFDFF 		jmp	.L207
 2522      FF
 2523 033b 0F1F4400 		.p2align 4,,10
 2523      00
 2524              		.p2align 3
 2525              	.L246:
 776:fltk-1.3.4-1/jpeg/jmemmgr.c ****     /* Flush old buffer contents if necessary */
 2526              		.loc 1 776 0
 2527 0340 488B03   		movq	(%rbx), %rax
 2528 0343 4889DF   		movq	%rbx, %rdi
 2529 0346 C7402847 		movl	$71, 40(%rax)
 2529      000000
 2530 034d 488B03   		movq	(%rbx), %rax
 2531 0350 FF10     		call	*(%rax)
 2532              	.LVL304:
 2533 0352 418B761C 		movl	28(%r14), %esi
 2534 0356 E911FDFF 		jmp	.L205
 2534      FF
 2535              	.L248:
 813:fltk-1.3.4-1/jpeg/jmemmgr.c ****       undef_row = start_row;	/* but reader is allowed to read ahead */
 2536              		.loc 1 813 0
 2537 035b 488B03   		movq	(%rbx), %rax
 2538 035e 4889DF   		movq	%rbx, %rdi
 2539 0361 C7402817 		movl	$23, 40(%rax)
 2539      000000
 2540 0368 488B03   		movq	(%rbx), %rax
 2541 036b FF10     		call	*(%rax)
 2542              	.LVL305:
 2543 036d 8B4C2414 		movl	20(%rsp), %ecx
 2544 0371 E9B6FEFF 		jmp	.L219
 2544      FF
 2545              	.LVL306:
 2546              	.L249:
 830:fltk-1.3.4-1/jpeg/jmemmgr.c ****     }
 2547              		.loc 1 830 0
 2548 0376 488B03   		movq	(%rbx), %rax
 2549 0379 4889DF   		movq	%rbx, %rdi
 2550 037c C7402817 		movl	$23, 40(%rax)
 2550      000000
 2551 0383 488B03   		movq	(%rbx), %rax
 2552 0386 FF10     		call	*(%rax)
 2553              	.LVL307:
 2554 0388 418B461C 		movl	28(%r14), %eax
 2555 038c E94EFEFF 		jmp	.L223
 2555      FF
 2556              	.LVL308:
 2557              		.p2align 4,,10
 2558 0391 0F1F8000 		.p2align 3
 2558      000000
 2559              	.L250:
 2560 0398 418B6E0C 		movl	12(%r14), %ebp
 2561              	.LVL309:
 2562 039c EB90     		jmp	.L209
 2563              		.cfi_endproc
 2564              	.LFE71:
 2566              		.section	.text.unlikely.access_virt_sarray
 2567              	.LCOLDE11:
 2568              		.section	.text.access_virt_sarray
 2569              	.LHOTE11:
 2570              		.section	.rodata.str1.1,"aMS",@progbits,1
 2571              	.LC12:
 2572 0000 4A504547 		.string	"JPEGMEM"
 2572      4D454D00 
 2573              	.LC13:
 2574 0008 256C6425 		.string	"%ld%c"
 2574      6300
 2575              		.section	.text.unlikely.jinit_memory_mgr,"ax",@progbits
 2576              	.LCOLDB14:
 2577              		.section	.text.jinit_memory_mgr,"ax",@progbits
 2578              	.LHOTB14:
 2579              		.p2align 4,,15
 2580              		.globl	jinit_memory_mgr
 2582              	jinit_memory_mgr:
 2583              	.LFB75:
1021:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
1022:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
1023:fltk-1.3.4-1/jpeg/jmemmgr.c **** /*
1024:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * Memory manager initialization.
1025:fltk-1.3.4-1/jpeg/jmemmgr.c ****  * When this is called, only the error manager pointer is valid in cinfo!
1026:fltk-1.3.4-1/jpeg/jmemmgr.c ****  */
1027:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
1028:fltk-1.3.4-1/jpeg/jmemmgr.c **** GLOBAL(void)
1029:fltk-1.3.4-1/jpeg/jmemmgr.c **** jinit_memory_mgr (j_common_ptr cinfo)
1030:fltk-1.3.4-1/jpeg/jmemmgr.c **** {
 2584              		.loc 1 1030 0
 2585              		.cfi_startproc
 2586              	.LVL310:
 2587 0000 55       		pushq	%rbp
 2588              		.cfi_def_cfa_offset 16
 2589              		.cfi_offset 6, -16
 2590 0001 53       		pushq	%rbx
 2591              		.cfi_def_cfa_offset 24
 2592              		.cfi_offset 3, -24
 2593 0002 4889FD   		movq	%rdi, %rbp
 2594 0005 4883EC28 		subq	$40, %rsp
 2595              		.cfi_def_cfa_offset 64
1031:fltk-1.3.4-1/jpeg/jmemmgr.c ****   my_mem_ptr mem;
1032:fltk-1.3.4-1/jpeg/jmemmgr.c ****   long max_to_use;
1033:fltk-1.3.4-1/jpeg/jmemmgr.c ****   int pool;
1034:fltk-1.3.4-1/jpeg/jmemmgr.c ****   size_t test_mac;
1035:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
1036:fltk-1.3.4-1/jpeg/jmemmgr.c ****   cinfo->mem = NULL;		/* for safety if init fails */
 2596              		.loc 1 1036 0
 2597 0009 48C74708 		movq	$0, 8(%rdi)
 2597      00000000 
 2598              	.LVL311:
1030:fltk-1.3.4-1/jpeg/jmemmgr.c ****   my_mem_ptr mem;
 2599              		.loc 1 1030 0
 2600 0011 64488B04 		movq	%fs:40, %rax
 2600      25280000 
 2600      00
 2601 001a 48894424 		movq	%rax, 24(%rsp)
 2601      18
 2602 001f 31C0     		xorl	%eax, %eax
1037:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
1038:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Check for configuration errors.
1039:fltk-1.3.4-1/jpeg/jmemmgr.c ****    * SIZEOF(ALIGN_TYPE) should be a power of 2; otherwise, it probably
1040:fltk-1.3.4-1/jpeg/jmemmgr.c ****    * doesn't reflect any real hardware alignment requirement.
1041:fltk-1.3.4-1/jpeg/jmemmgr.c ****    * The test is a little tricky: for X>0, X and X-1 have no one-bits
1042:fltk-1.3.4-1/jpeg/jmemmgr.c ****    * in common if and only if X is a power of 2, ie has only one one-bit.
1043:fltk-1.3.4-1/jpeg/jmemmgr.c ****    * Some compilers may give an "unreachable code" warning here; ignore it.
1044:fltk-1.3.4-1/jpeg/jmemmgr.c ****    */
1045:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if ((SIZEOF(ALIGN_TYPE) & (SIZEOF(ALIGN_TYPE)-1)) != 0)
1046:fltk-1.3.4-1/jpeg/jmemmgr.c ****     ERREXIT(cinfo, JERR_BAD_ALIGN_TYPE);
1047:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* MAX_ALLOC_CHUNK must be representable as type size_t, and must be
1048:fltk-1.3.4-1/jpeg/jmemmgr.c ****    * a multiple of SIZEOF(ALIGN_TYPE).
1049:fltk-1.3.4-1/jpeg/jmemmgr.c ****    * Again, an "unreachable code" warning may be ignored here.
1050:fltk-1.3.4-1/jpeg/jmemmgr.c ****    * But a "constant too large" warning means you need to fix MAX_ALLOC_CHUNK.
1051:fltk-1.3.4-1/jpeg/jmemmgr.c ****    */
1052:fltk-1.3.4-1/jpeg/jmemmgr.c ****   test_mac = (size_t) MAX_ALLOC_CHUNK;
1053:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if ((long) test_mac != MAX_ALLOC_CHUNK ||
1054:fltk-1.3.4-1/jpeg/jmemmgr.c ****       (MAX_ALLOC_CHUNK % SIZEOF(ALIGN_TYPE)) != 0)
1055:fltk-1.3.4-1/jpeg/jmemmgr.c ****     ERREXIT(cinfo, JERR_BAD_ALLOC_CHUNK);
1056:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
1057:fltk-1.3.4-1/jpeg/jmemmgr.c ****   max_to_use = jpeg_mem_init(cinfo); /* system-dependent initialization */
 2603              		.loc 1 1057 0
 2604 0021 E8000000 		call	jpeg_mem_init
 2604      00
 2605              	.LVL312:
1058:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
1059:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Attempt to allocate memory manager's control block */
1060:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem = (my_mem_ptr) jpeg_get_small(cinfo, SIZEOF(my_memory_mgr));
 2606              		.loc 1 1060 0
 2607 0026 BEA80000 		movl	$168, %esi
 2607      00
 2608 002b 4889EF   		movq	%rbp, %rdi
1057:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 2609              		.loc 1 1057 0
 2610 002e 48894424 		movq	%rax, 16(%rsp)
 2610      10
 2611              		.loc 1 1060 0
 2612 0033 E8000000 		call	jpeg_get_small
 2612      00
 2613              	.LVL313:
1061:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
1062:fltk-1.3.4-1/jpeg/jmemmgr.c ****   if (mem == NULL) {
 2614              		.loc 1 1062 0
 2615 0038 4885C0   		testq	%rax, %rax
1060:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 2616              		.loc 1 1060 0
 2617 003b 4889C3   		movq	%rax, %rbx
 2618              	.LVL314:
 2619              		.loc 1 1062 0
 2620 003e 0F842C01 		je	.L262
 2620      0000
 2621              	.LVL315:
 2622              	.L252:
1063:fltk-1.3.4-1/jpeg/jmemmgr.c ****     jpeg_mem_term(cinfo);	/* system-dependent cleanup */
1064:fltk-1.3.4-1/jpeg/jmemmgr.c ****     ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, 0);
1065:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
1066:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
1067:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* OK, fill in the method pointers */
1068:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->pub.alloc_small = alloc_small;
 2623              		.loc 1 1068 0
 2624 0044 48C70300 		movq	$alloc_small, (%rbx)
 2624      000000
1069:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->pub.alloc_large = alloc_large;
1070:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->pub.alloc_sarray = alloc_sarray;
1071:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->pub.alloc_barray = alloc_barray;
1072:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->pub.request_virt_sarray = request_virt_sarray;
1073:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->pub.request_virt_barray = request_virt_barray;
1074:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->pub.realize_virt_arrays = realize_virt_arrays;
1075:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->pub.access_virt_sarray = access_virt_sarray;
1076:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->pub.access_virt_barray = access_virt_barray;
1077:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->pub.free_pool = free_pool;
1078:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->pub.self_destruct = self_destruct;
1079:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
1080:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Make MAX_ALLOC_CHUNK accessible to other modules */
1081:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->pub.max_alloc_chunk = MAX_ALLOC_CHUNK;
1082:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
1083:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Initialize working state */
1084:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->pub.max_memory_to_use = max_to_use;
 2625              		.loc 1 1084 0
 2626 004b 488B4424 		movq	16(%rsp), %rax
 2626      10
 2627              	.LBB53:
1085:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
1086:fltk-1.3.4-1/jpeg/jmemmgr.c ****   for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
1087:fltk-1.3.4-1/jpeg/jmemmgr.c ****     mem->small_list[pool] = NULL;
1088:fltk-1.3.4-1/jpeg/jmemmgr.c ****     mem->large_list[pool] = NULL;
1089:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
1090:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->virt_sarray_list = NULL;
1091:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->virt_barray_list = NULL;
1092:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
1093:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->total_space_allocated = SIZEOF(my_memory_mgr);
1094:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
1095:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Declare ourselves open for business */
1096:fltk-1.3.4-1/jpeg/jmemmgr.c ****   cinfo->mem = & mem->pub;
1097:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
1098:fltk-1.3.4-1/jpeg/jmemmgr.c ****   /* Check for an environment variable JPEGMEM; if found, override the
1099:fltk-1.3.4-1/jpeg/jmemmgr.c ****    * default max_memory setting from jpeg_mem_init.  Note that the
1100:fltk-1.3.4-1/jpeg/jmemmgr.c ****    * surrounding application may again override this value.
1101:fltk-1.3.4-1/jpeg/jmemmgr.c ****    * If your system doesn't support getenv(), define NO_GETENV to disable
1102:fltk-1.3.4-1/jpeg/jmemmgr.c ****    * this feature.
1103:fltk-1.3.4-1/jpeg/jmemmgr.c ****    */
1104:fltk-1.3.4-1/jpeg/jmemmgr.c **** #ifndef NO_GETENV
1105:fltk-1.3.4-1/jpeg/jmemmgr.c ****   { char * memenv;
1106:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
1107:fltk-1.3.4-1/jpeg/jmemmgr.c ****     if ((memenv = getenv("JPEGMEM")) != NULL) {
 2628              		.loc 1 1107 0
 2629 0050 BF000000 		movl	$.LC12, %edi
 2629      00
 2630              	.LBE53:
1069:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->pub.alloc_large = alloc_large;
 2631              		.loc 1 1069 0
 2632 0055 48C74308 		movq	$alloc_large, 8(%rbx)
 2632      00000000 
1070:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->pub.alloc_barray = alloc_barray;
 2633              		.loc 1 1070 0
 2634 005d 48C74310 		movq	$alloc_sarray, 16(%rbx)
 2634      00000000 
1071:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->pub.request_virt_sarray = request_virt_sarray;
 2635              		.loc 1 1071 0
 2636 0065 48C74318 		movq	$alloc_barray, 24(%rbx)
 2636      00000000 
1072:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->pub.request_virt_barray = request_virt_barray;
 2637              		.loc 1 1072 0
 2638 006d 48C74320 		movq	$request_virt_sarray, 32(%rbx)
 2638      00000000 
1073:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->pub.realize_virt_arrays = realize_virt_arrays;
 2639              		.loc 1 1073 0
 2640 0075 48C74328 		movq	$request_virt_barray, 40(%rbx)
 2640      00000000 
1074:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->pub.access_virt_sarray = access_virt_sarray;
 2641              		.loc 1 1074 0
 2642 007d 48C74330 		movq	$realize_virt_arrays, 48(%rbx)
 2642      00000000 
1075:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->pub.access_virt_barray = access_virt_barray;
 2643              		.loc 1 1075 0
 2644 0085 48C74338 		movq	$access_virt_sarray, 56(%rbx)
 2644      00000000 
1076:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->pub.free_pool = free_pool;
 2645              		.loc 1 1076 0
 2646 008d 48C74340 		movq	$access_virt_barray, 64(%rbx)
 2646      00000000 
1077:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->pub.self_destruct = self_destruct;
 2647              		.loc 1 1077 0
 2648 0095 48C74348 		movq	$free_pool, 72(%rbx)
 2648      00000000 
1078:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 2649              		.loc 1 1078 0
 2650 009d 48C74350 		movq	$self_destruct, 80(%rbx)
 2650      00000000 
1081:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 2651              		.loc 1 1081 0
 2652 00a5 48C74360 		movq	$1000000000, 96(%rbx)
 2652      00CA9A3B 
1084:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 2653              		.loc 1 1084 0
 2654 00ad 48894358 		movq	%rax, 88(%rbx)
 2655              	.LVL316:
1087:fltk-1.3.4-1/jpeg/jmemmgr.c ****     mem->large_list[pool] = NULL;
 2656              		.loc 1 1087 0
 2657 00b1 48C74370 		movq	$0, 112(%rbx)
 2657      00000000 
1088:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
 2658              		.loc 1 1088 0
 2659 00b9 48C78380 		movq	$0, 128(%rbx)
 2659      00000000 
 2659      000000
 2660              	.LVL317:
1087:fltk-1.3.4-1/jpeg/jmemmgr.c ****     mem->large_list[pool] = NULL;
 2661              		.loc 1 1087 0
 2662 00c4 48C74368 		movq	$0, 104(%rbx)
 2662      00000000 
1088:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
 2663              		.loc 1 1088 0
 2664 00cc 48C74378 		movq	$0, 120(%rbx)
 2664      00000000 
 2665              	.LVL318:
1090:fltk-1.3.4-1/jpeg/jmemmgr.c ****   mem->virt_barray_list = NULL;
 2666              		.loc 1 1090 0
 2667 00d4 48C78388 		movq	$0, 136(%rbx)
 2667      00000000 
 2667      000000
1091:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 2668              		.loc 1 1091 0
 2669 00df 48C78390 		movq	$0, 144(%rbx)
 2669      00000000 
 2669      000000
1093:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 2670              		.loc 1 1093 0
 2671 00ea 48C78398 		movq	$168, 152(%rbx)
 2671      000000A8 
 2671      000000
1096:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
 2672              		.loc 1 1096 0
 2673 00f5 48895D08 		movq	%rbx, 8(%rbp)
 2674              	.LBB56:
 2675              		.loc 1 1107 0
 2676 00f9 E8000000 		call	getenv
 2676      00
 2677              	.LVL319:
 2678 00fe 4885C0   		testq	%rax, %rax
 2679 0101 743E     		je	.L251
 2680              	.LBB54:
1108:fltk-1.3.4-1/jpeg/jmemmgr.c ****       char ch = 'x';
1109:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
1110:fltk-1.3.4-1/jpeg/jmemmgr.c ****       if (sscanf(memenv, "%ld%c", &max_to_use, &ch) > 0) {
 2681              		.loc 1 1110 0
 2682 0103 488D4C24 		leaq	15(%rsp), %rcx
 2682      0F
 2683 0108 488D5424 		leaq	16(%rsp), %rdx
 2683      10
 2684 010d 4889C7   		movq	%rax, %rdi
 2685 0110 BE000000 		movl	$.LC13, %esi
 2685      00
 2686 0115 31C0     		xorl	%eax, %eax
 2687              	.LVL320:
1108:fltk-1.3.4-1/jpeg/jmemmgr.c ****       char ch = 'x';
 2688              		.loc 1 1108 0
 2689 0117 C644240F 		movb	$120, 15(%rsp)
 2689      78
 2690              		.loc 1 1110 0
 2691 011c E8000000 		call	__isoc99_sscanf
 2691      00
 2692              	.LVL321:
 2693 0121 85C0     		testl	%eax, %eax
 2694 0123 7E1C     		jle	.L251
1111:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	if (ch == 'm' || ch == 'M')
 2695              		.loc 1 1111 0
 2696 0125 0FB64424 		movzbl	15(%rsp), %eax
 2696      0F
 2697 012a 83E0DF   		andl	$-33, %eax
 2698 012d 3C4D     		cmpb	$77, %al
 2699 012f 742F     		je	.L255
 2700 0131 488B4424 		movq	16(%rsp), %rax
 2700      10
 2701              	.L256:
1112:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	  max_to_use *= 1000L;
1113:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	mem->pub.max_memory_to_use = max_to_use * 1000L;
 2702              		.loc 1 1113 0
 2703 0136 4869C0E8 		imulq	$1000, %rax, %rax
 2703      030000
 2704 013d 48894358 		movq	%rax, 88(%rbx)
 2705              	.L251:
 2706              	.LBE54:
 2707              	.LBE56:
1114:fltk-1.3.4-1/jpeg/jmemmgr.c ****       }
1115:fltk-1.3.4-1/jpeg/jmemmgr.c ****     }
1116:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
1117:fltk-1.3.4-1/jpeg/jmemmgr.c **** #endif
1118:fltk-1.3.4-1/jpeg/jmemmgr.c **** 
1119:fltk-1.3.4-1/jpeg/jmemmgr.c **** }
 2708              		.loc 1 1119 0
 2709 0141 488B4424 		movq	24(%rsp), %rax
 2709      18
 2710 0146 64483304 		xorq	%fs:40, %rax
 2710      25280000 
 2710      00
 2711 014f 754B     		jne	.L263
 2712 0151 4883C428 		addq	$40, %rsp
 2713              		.cfi_remember_state
 2714              		.cfi_def_cfa_offset 24
 2715 0155 5B       		popq	%rbx
 2716              		.cfi_def_cfa_offset 16
 2717              	.LVL322:
 2718 0156 5D       		popq	%rbp
 2719              		.cfi_def_cfa_offset 8
 2720              	.LVL323:
 2721 0157 C3       		ret
 2722              	.LVL324:
 2723 0158 0F1F8400 		.p2align 4,,10
 2723      00000000 
 2724              		.p2align 3
 2725              	.L255:
 2726              		.cfi_restore_state
 2727              	.LBB57:
 2728              	.LBB55:
1112:fltk-1.3.4-1/jpeg/jmemmgr.c **** 	  max_to_use *= 1000L;
 2729              		.loc 1 1112 0
 2730 0160 48694424 		imulq	$1000, 16(%rsp), %rax
 2730      10E80300 
 2730      00
 2731              	.LVL325:
 2732 0169 EBCB     		jmp	.L256
 2733              	.LVL326:
 2734 016b 0F1F4400 		.p2align 4,,10
 2734      00
 2735              		.p2align 3
 2736              	.L262:
 2737              	.LBE55:
 2738              	.LBE57:
1063:fltk-1.3.4-1/jpeg/jmemmgr.c ****     ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, 0);
 2739              		.loc 1 1063 0
 2740 0170 4889EF   		movq	%rbp, %rdi
 2741 0173 E8000000 		call	jpeg_mem_term
 2741      00
 2742              	.LVL327:
1064:fltk-1.3.4-1/jpeg/jmemmgr.c ****   }
 2743              		.loc 1 1064 0
 2744 0178 488B4500 		movq	0(%rbp), %rax
 2745 017c 4889EF   		movq	%rbp, %rdi
 2746 017f C7402838 		movl	$56, 40(%rax)
 2746      000000
 2747 0186 488B4500 		movq	0(%rbp), %rax
 2748 018a C7402C00 		movl	$0, 44(%rax)
 2748      000000
 2749 0191 488B4500 		movq	0(%rbp), %rax
 2750 0195 FF10     		call	*(%rax)
 2751              	.LVL328:
 2752 0197 E9A8FEFF 		jmp	.L252
 2752      FF
 2753              	.LVL329:
 2754              	.L263:
 2755              		.loc 1 1119 0
 2756 019c E8000000 		call	__stack_chk_fail
 2756      00
 2757              	.LVL330:
 2758              		.cfi_endproc
 2759              	.LFE75:
 2761              		.section	.text.unlikely.jinit_memory_mgr
 2762              	.LCOLDE14:
 2763              		.section	.text.jinit_memory_mgr
 2764              	.LHOTE14:
 2765              		.section	.rodata.extra_pool_slop,"a",@progbits
 2766              		.align 16
 2769              	extra_pool_slop:
 2770 0000 00000000 		.quad	0
 2770      00000000 
 2771 0008 88130000 		.quad	5000
 2771      00000000 
 2772              		.section	.rodata.first_pool_slop,"a",@progbits
 2773              		.align 16
 2776              	first_pool_slop:
 2777 0000 40060000 		.quad	1600
 2777      00000000 
 2778 0008 803E0000 		.quad	16000
 2778      00000000 
 2779              		.text
 2780              	.Letext0:
 2781              		.section	.text.unlikely.do_barray_io
 2782              	.Letext_cold0:
 2783              		.file 3 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
 2784              		.file 4 "/usr/include/x86_64-linux-gnu/bits/types.h"
 2785              		.file 5 "/usr/include/stdio.h"
 2786              		.file 6 "/usr/include/libio.h"
 2787              		.file 7 "fltk-1.3.4-1/jpeg/jmorecfg.h"
 2788              		.file 8 "fltk-1.3.4-1/jpeg/jpeglib.h"
 2789              		.file 9 "fltk-1.3.4-1/jpeg/jerror.h"
 2790              		.file 10 "fltk-1.3.4-1/jpeg/jmemsys.h"
 2791              		.file 11 "/usr/include/stdlib.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 jmemmgr.c
     /tmp/cccJLpac.s:13     .text.do_barray_io:0000000000000000 do_barray_io
     /tmp/cccJLpac.s:188    .text.alloc_small:0000000000000000 alloc_small
     /tmp/cccJLpac.s:2769   .rodata.extra_pool_slop:0000000000000000 extra_pool_slop
     /tmp/cccJLpac.s:2776   .rodata.first_pool_slop:0000000000000000 first_pool_slop
     /tmp/cccJLpac.s:443    .text.request_virt_barray:0000000000000000 request_virt_barray
     /tmp/cccJLpac.s:549    .text.request_virt_sarray:0000000000000000 request_virt_sarray
     /tmp/cccJLpac.s:655    .text.free_pool:0000000000000000 free_pool
     /tmp/cccJLpac.s:878    .text.self_destruct:0000000000000000 self_destruct
     /tmp/cccJLpac.s:927    .text.access_virt_barray:0000000000000000 access_virt_barray
     /tmp/cccJLpac.s:1213   .text.alloc_large:0000000000000000 alloc_large
     /tmp/cccJLpac.s:1365   .text.alloc_barray:0000000000000000 alloc_barray
     /tmp/cccJLpac.s:1538   .text.alloc_sarray:0000000000000000 alloc_sarray
     /tmp/cccJLpac.s:1707   .text.realize_virt_arrays:0000000000000000 realize_virt_arrays
     /tmp/cccJLpac.s:2059   .text.access_virt_sarray:0000000000000000 access_virt_sarray
     /tmp/cccJLpac.s:2582   .text.jinit_memory_mgr:0000000000000000 jinit_memory_mgr
                           .group:0000000000000000 wm4.0.cf9695abff4f49bdfe00dc4091904acd
                           .group:0000000000000000 wm4.stdcpredef.h.19.bf2bf6c5fb087dfb5ef2d2297c2795de
                           .group:0000000000000000 wm4.jconfig.h.10.247fc3ff67998f3074970b1373c70333
                           .group:0000000000000000 wm4.features.h.19.24da27e0a4d0d521fd057013d982b8b5
                           .group:0000000000000000 wm4.cdefs.h.19.56613e71f285ebad825b69b151170a81
                           .group:0000000000000000 wm4.wordsize.h.4.256e8fdbd37801980286acdbc40d0280
                           .group:0000000000000000 wm4.cdefs.h.432.619afd0aac7c4b439843706c1b28ddea
                           .group:0000000000000000 wm4.stubs64.h.10.918ceb5fa58268542bf143e4c1efbcf3
                           .group:0000000000000000 wm4.stdlib.h.27.59e2586c75bdbcb991b248ad7257b993
                           .group:0000000000000000 wm4.stddef.h.187.e1c83cba2098ce92b68f6311de19e6b1
                           .group:0000000000000000 wm4.waitflags.h.25.e401b8bcfee800b540b27abd7cc78de9
                           .group:0000000000000000 wm4.waitstatus.h.28.93f167f49d64e2b9b99f98d1162a93bf
                           .group:0000000000000000 wm4.endian.h.19.ff00c9c0f5e9f9a9719c5de76ace57b4
                           .group:0000000000000000 wm4.endian.h.41.24cced64aef71195a51d4daa8e4f4a95
                           .group:0000000000000000 wm4.types.h.89.468e2451361e3b92f048f6cad51690ff
                           .group:0000000000000000 wm4.typesizes.h.24.40eb69a6270178f15d1bf3d7b6635a8b
                           .group:0000000000000000 wm4.byteswap.h.38.11ee5fdc0f6cc53a16c505b9233cecef
                           .group:0000000000000000 wm4.endian.h.63.97272d7c64d5db8020003b32e9289502
                           .group:0000000000000000 wm4.waitstatus.h.99.408b6270fa6eb71377201a241ef15f79
                           .group:0000000000000000 wm4.stdlib.h.50.84aeca2ac6f37d40e1e9b3cef757ba2d
                           .group:0000000000000000 wm4.types.h.23.f6dcbaa72f8f71361acef09804d45a5e
                           .group:0000000000000000 wm4.time.h.53.beb46e650cd406cb917b6b96b45e640a
                           .group:0000000000000000 wm4.stddef.h.238.847b6907dabda77be90a9ab7ad789e2e
                           .group:0000000000000000 wm4.types.h.187.bd5a05039b505b3620e6973f1b2ffeb1
                           .group:0000000000000000 wm4.select.h.28.eb2f3debdbcffd1442ebddaebc4fb6ff
                           .group:0000000000000000 wm4.sigset.h.20.f36413b6d2364ad847d3db53fb03e683
                           .group:0000000000000000 wm4.select.h.36.f76c3b9e55c871743863013cc4cc14c9
                           .group:0000000000000000 wm4.time.h.66.e70ce69790c975f0efb369340c432e0b
                           .group:0000000000000000 wm4.time.h.25.ae5284cdff565e87a9198d819340325d
                           .group:0000000000000000 wm4.select.h.49.e9d2041e5035cc68ebd1a20f7dbc8514
                           .group:0000000000000000 wm4.select2.h.27.f95f2ab0ffee66dc1b6575014894b21a
                           .group:0000000000000000 wm4.sysmacros.h.20.8a0c33ff175cd9b434a86c0aaa36f0a2
                           .group:0000000000000000 wm4.types.h.229.67b3f66bd74b06b451caec392a72a945
                           .group:0000000000000000 wm4.pthreadtypes.h.25.6892b1493314fcf446bbc76e7362acba
                           .group:0000000000000000 wm4.alloca.h.19.edefa922a76c1cbaaf1e416903ba2d1c
                           .group:0000000000000000 wm4.alloca.h.29.156e12058824cc23d961c4d3b13031f6
                           .group:0000000000000000 wm4.stdio.h.26.4719156f1aea2bb9662fd6c582dc9a4c
                           .group:0000000000000000 wm4.stddef.h.238.04cc7214bceba497b20d15c10fd97511
                           .group:0000000000000000 wm4.stdio.h.36.2dd12c1fd035242ad5cfd0152a01be5a
                           .group:0000000000000000 wm4._G_config.h.5.b0f37d9e474454cf6e459063458db32f
                           .group:0000000000000000 wm4.wchar.h.80.eea3eba2d2a17aace9470a8e0d8218dc
                           .group:0000000000000000 wm4._G_config.h.46.5187c97b14fd664662cb32e6b94fc49e
                           .group:0000000000000000 wm4.libio.h.33.a775b9ecae273f33bc59931e9891e4ca
                           .group:0000000000000000 wm4.stdarg.h.34.3a23a216c0c293b3d2ea2e89281481e6
                           .group:0000000000000000 wm4.libio.h.51.dab170798ec1df48c625aea7c30e1b63
                           .group:0000000000000000 wm4.stdio.h.80.17b7dd1ca72d8a61987532cb1d80194a
                           .group:0000000000000000 wm4.stdio_lim.h.23.557290a6cddeba0587f574f29e3a5fb9
                           .group:0000000000000000 wm4.stdio.h.172.df21df34a7396d7da2e08f9b617d582f
                           .group:0000000000000000 wm4.stdio.h.26.cae64f7ada9bb8327a89dba6a5e93655
                           .group:0000000000000000 wm4.string.h.23.8394011d5995a16f15d67d04e84a1d69
                           .group:0000000000000000 wm4.string.h.24.1b0dc67418e7128d207285861439c2f8
                           .group:0000000000000000 wm4.string2.h.45.00535b99420fc3014c2da41d6645330d
                           .group:0000000000000000 wm4.string3.h.31.0c4b9301b754a2db05eaafef869657d2
                           .group:0000000000000000 wm4.jinclude.h.67.b19f941ec97c4845fa4609292c7e2db4
                           .group:0000000000000000 wm4.jmorecfg.h.33.3b4c5f9cc07b3737823b06caf24d5b05
                           .group:0000000000000000 wm4.jpeglib.h.40.4f111c27252a38df39328d65454e82f4
                           .group:0000000000000000 wm4.jpegint.h.26.5219ef5d4e4921371d38e77b6091fd20
                           .group:0000000000000000 wm4.jerror.h.25.1dbd8674e70ab5215bc0037320e5c2a2
                           .group:0000000000000000 wm4.jmemsys.h.78.e8417de29834b6ee7fe4d9b9f74aec3c

UNDEFINED SYMBOLS
jpeg_get_small
jpeg_free_large
jpeg_free_small
jpeg_mem_term
memset
jpeg_get_large
jpeg_mem_available
jpeg_open_backing_store
jpeg_mem_init
getenv
__isoc99_sscanf
__stack_chk_fail
